---
title: 宏定义
abbrlink: 39968
date: 2022-11-22 15:48:12
tags:
---

# 无参宏：宏名后不带参数

```#define
#define 宏名 替代的文本
```

每个#define行（即逻辑行）由三部分组成：

第一部分是指令 **#define** 自身，“**#**”表示这是一条预处理命令，“**define**”为宏命令；

第二部分为宏，一般为缩略语，其名称（宏名）一般大写，而且不能有空格，遵循C变量命令规则。“替换文本”可以是任意常数、表达式、字符串等；

第三部分是替换的文本，在预处理工作过程中，代码中所有出现的“宏名”，都会被“替换的文本”替换。这个替换的过程被称为“宏代换”或“宏展开”。“宏代换”是由预处理程序自动完成的。在C语言中，“宏”分为两种：无参数 和 有参数。

“**#**”可以不在行首，但只允许它前面有空格符；

 标识符和替换列表之间不能加赋值号 =，替换列表后不能加分号；

如果要写宏不止一行，则在结尾加反斜线符号使得多行能连接上，

```
#define HELLO "hello \
the world"
```

注意：行与行之间的空格也会被作为替换文本的一部分；

宏名如果出现在源程序中的 “ ”（括号）内，则不会被当做宏来进行宏代换；

宏可以嵌套，但不参与运算；

宏定义必须写在函数之外，其作用域是 #**define** 开始，到源程序结束。如果要提前结束它的作用域则用 #**undef 标识符** 命令；

可以用宏定义表示数据类型，可以使代码简便：

```
#define STU struct Student      // 宏定义STU
struct Student{                 // 定义结构体Student
    char *name;
    int sNo;
};
STU stu = {"Jack", 20};         // 被替换为：struct Student stu = {"Jack", 20};
printf("name: %s, sNo: %d\n", stu.name, stu.sNo);
```

# 有参宏

```
#define 宏名（参数，参数···） 替换主体（表达式）
```

和函数类似，在宏定义中的参数成为形式参数，在宏调用中的参数成为实际参数。

而且和无参宏不同的一点是，有参宏在调用中，不仅要进行宏展开，而且还要用实参去替换形参。如：

```c
#define M 5                          //无参宏
#define COUNT(M) M * M               //有参宏
printf("COUNT = %d\n", COUNT(10));   // 替换为： COUNT(10) = 10 * 10
                                     // 输出结果： COUNT = 100
```

这看上去用法与函数调用类似，但实际上是有很大差别的。如：

```c
#define COUNT(M) M * M               //定义有参宏
int x = 6;
printf("COUNT = %d\n", COUNT(x + 1));// 输出结果： COUNT = 13
printf("COUNT = %d\n", COUNT(++x));  // 输出结果： COUNT = 56                                                                                               //warning:... main.c:161:34: Multiple unsequenced             modifications to 'x'
```

这两个结果和调用函数的方法的结果差别很大，因为如果是像函数那样的话，COUNT(x + 1)应该相当于COUNT(7)，结果应该是 7 * 7 = 49，但输出结果却是21。原因在于，预处理器不进行技术，只是进行字符串替换，而且也不会自动加上括号（），所以COUNT(x + 1)被替换为 COUNT(x + 1 * x + 1)，代入 x = 6，即为 6 + 1 * 6 + 1 = 13。而解决办法则是：尽量用括号把整个替换文本及其中的每个参数括起来：

```c
#define COUNT(M) ((M) * (M))  
```

但即使用括号，也不能解决上面例子的最后一个情况，COUNT(++x) 被替换为 ++x * ++x，即为 7 * 8 = 56，而不是想要 7 * 7 = 49，解决办法最简单的是：不要在有参宏用使用到“++”、“–”等。

上面说到宏名中不能有空格，宏名与形参表之间也不能有空格，而形参表中形参之间可以出现空格：

```c
#define SUM (a,b) a + b              //定义有参宏
printf("SUM = %d\n", SUM(1,2));      //调用有参宏。Build Failed！
因为 SUM 被替换为：(a,b) a + b
```

如果用函数求一个整数的平方，则是：

```c
int count(int x){
    return x * x;
}
```

所以在宏定义中：#define COUNT(M) M * M 中的形参不分配内存单元，所以不作类型定义。而函数 int count(int x)中形参是局部变量，会在栈区分配内存单元，所以要作类型定义，而且实参与形参之间是“值传递”。而宏只是符号代换，不存在值传递。

宏定义也可以用来定义表达式或者多个语句。如：

```c
#define JI(a,b) a = i + 3; b = j + 5;   //宏定义多个语句
int i = 5, j = 10;
int m = 0, n = 0;
JI(m, n);                               // 宏代换后为： m = i + 3, n = j + 5;
printf("m = %d, n = %d\n", m, n);       // 输出结果为： m = 8, n = 15
```

**3、# 运算符**

比如如果我们宏定义了：

```c
#define SUM (a,b) ((a) + (b)) 
```

我们想要输出“1 + 2 + 3 + 4 = 10”，用以下方式显得比较麻烦，有重复代码，而且中间还有括号：

```c
printf("(%d + %d) + (%d + %d) = %d\n", 1, 2, 3, 4, SUM(1 + 2, 3+ 4));
```

那么这时可以考虑用 # 运算符来在字符串中包含宏参数，# 运算符的用处就是把语言符号转化为字符串。例如，如果 a 是一个宏的形参，则替换文本中的 #a 则被系统转化为 “a”。而这个转化的过程成为 “字符串化（stringizing）”。用这个方法实现上面的要求：

```c
#define SUM(a,b) printf(#a " + "#b" = %d\n",((a) + (b)))    //宏定义，运用 # 运算符
SUM(1 + 2, 3 + 4);                                          //宏调用
//输出结果：1 + 2 + 3 + 4 = 10
```

调用宏时，用 1 + 2 代替 a，用 3 + 4 代替b，则替换文本为：printf(“1 + 2” ” + ” “3 + 4” ” = %d\n”,((1 + 2) + (3 + 4)))，接着字符串连接功能将四个相邻的字符串转换为一个字符串：

```c
"1 + 2 + 3 + 4 = %d\n"
```

**4、## 运算符**

和 # 运算符一样，## 运算符也可以用在替换文本中，而它的作用是起到粘合的作用，即将两个语言符号组合成一个语言符号，所以又称为“预处理器的粘合剂（Preprocessor Glue）”。用法：

```c
#define NAME(n) num ## n            //宏定义，使用 ## 运算符
int num0 = 10;
printf("num0 = %d\n", NAME(0));     //宏调用
```

NAME(0)被替换为 num ## 0，被粘合为： num0。

**5、可变宏：… 和 __VA_ARGS__**

我们经常要输出结果时要多次使用 prinf(“…”, …); 如果用上面例子#define SUM(a,b) printf(#a ” + “#b” = %d\n”,((a) + (b)))，则格式比较固定，不能用于输出其他格式。

这时我们可以考虑用可变宏（Variadic Macros）。用法是：

```c
#define PR(...) printf(__VA_ARGS__)     //宏定义
PR("hello\n");                          //宏调用
//输出结果：hello
```

在宏定义中，形参列表的最后一个参数为省略号“…”，而“__VA_ARGS__”就可以被用在替换文本中，来表示省略号“…”代表了什么。而上面例子宏代换之后为： printf(“hello\n”);

还有个例子如：

```c
#define PR2(X, ...) printf("Message"#X":"__VA_ARGS__)   //宏定义
double msg = 10;
PR2(1, "msg = %.2f\n", msg);                            //宏调用
//输出结果：Message1:msg = 10.00
```

在宏调用中，X的值为1，所以 #X 被替换为”1”。宏代换后为：

```c
printf("Message""1"":""msg = %.2f\n", msg);
```

接着这4个字符串连接成一个：

```c
printf("Message1:msg = %.2f\n", msg);
```

要注意的是：省略号“…”只能用来替换宏的形参列表中最后一个！
