---
title: 指针动态数组（1）
abbrlink: 8844
date: 2022-10-25 15:14:22
tags:
---

# malloc函数

1. 头文件：#include <malloc.h>；

2. 使用：(void *)malloc(sizeof(void)*num);

其中void指示类型，sizeof是计算一个这个类型需要的字节，*num表示需要多少个这个类型的字节的空间，malloc后面的括号内也可以直接用数字填入，表示需要多少个字节的空间；

3. 成功返回分配空间的首地址，不成功则返回空指针NULL；

4. 当内存不再使用时应使用free()函数将内存块释放掉；

```
#include<malloc.h>
int *a;
int n;
a=(int *)malloc(sizeof(int)*n)
```

# free函数

1. 头文件：free函数头文件和malloc函数一致，即<malloc.h>;

2. 使用：free(a);a=NULL;

free后要将指针指向NULL，避免成为野指针；因为free是将指针所指向的那片内存清除，但是指针所指向的地址仍然是相同的，如果不对指针进行处理，指针将会成为野指针；

# calloc函数

1. 头文件：#include<stdlib.h>或者#include <malloc.h>;

2. 使用:(void *)calloc(num,sizeof(void));

calloc函数与free函数配套使用，calloc函数与malloc函数几乎相同，返回类型为空指针；

num表示需要的空间类型的数量，void表示需要的类型，

3. 区别:malloc的使用效率更加高，因为callloc函数在申请动态空间时会将每一个字节都初始化为0；

# realloc函数

1. 头文件:#include<stdio.h>或者#include <malloc.h>

2. 使用:(void *)realloc(指针,num *sizeof(int)；

3. 介绍:realloc是对动态内存进行扩容(即已经申请的动态空间不够使用，需要进行扩容，指针为原来的空间地址的指针，num为扩容后的大小；

实际上如果num比较小，即原空间后面还有空余的内存空间，并且原空间加上空闲空间等于num，则系统将直接在原内存空间后面扩容，**并返回原动态空间地址**；如果num比较大，原来申请的空间后面没有足够大的空间扩容，系统将重新申请一块(num*sizeof(void))的内存，并把原来空间的内容拷贝过去，原来空间进行free操作，因此原空间不需要进行free操作，**同时返回寻找到的空间的地址**;如果num非常大，系统内存申请失败，**返回NULL**,原来的内存不会释放。

注意：(1)如果扩容后的内存空间比原空间小，将会出现数据丢失，如果直接realloc(p, 0);相当于free(p);

(2)若realloc成功，指向原内存地址的指针就成了**悬挂指针**，即指针指向了一块没有分配给用户使用的内存，如果再用该指针进行操作就可能发生意想不到的问题。所以在应用realloc是应当格外注意这种情况;

(3)传递给realloc的[指针必须是先前通过malloc,calloc 或realloc()分配的;

(4)传递的指针可以为空，等同于malloc;

~~ps:还有new与delete函数，累了下次写；~~
