---
title: 快速排序
abbrlink: 11306
date: 2022-10-11 21:18:51
tags:
---

快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。

该方法的基本思想是：

- 1．先从数列中取出一个数作为基准数。//*一般是中间值*
- 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
- 3．再对左右区间重复第二步，直到各区间只有一个数。

并且快速排序还有一个比较简单的思想，就是递归。对于每一趟排序都是一样的思想，只不过需要进行排序的数组的范围越来越小了，使用递归实现这种排序最适合不过了。

## 快速排序的特点及性能

快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。  

但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 `O(n2)`，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 `O(nlogn)`，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。  

快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 `O(logn)`，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 `O(n)`。所以我们一般认为快速排序的空间复杂度为 `O(logn)`。  

快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。  

快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。

## 解析

| 7   | 2   | 4   | 6   | 1   | 3   | 8   | 9   | 12  | 0   |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

取数组的中间值作为基准值， 这组数据中取中间值1为基准值，

设i=1,j=10,a[i]=7,a[10]=0,mid=5,a[mid]=1;

寻找比中值(a[mid]=1)大的数，即i=1;接着寻找比中值小的数，即j=10；

将a[i=1]=7与a[j=10]=0交换，同时i++,j--，即此时i=2,j=9;此时数组为

| 0   | 2   | 4   | 6   | 1   | 3   | 8   | 9   | 12  | 7   |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

因为i与j还未相遇，即i与J之间还可能存在需要交换的数字，重新进入循环，

进入第二次交换时i=2,j=5,此时a[i]=2与a[j]=1交换，数组如下

| 0   | 1   | 4   | 6   | 2   | 3   | 8   | 9   | 12  | 7   |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

接着进行i++与j--；此时i=3,j=4;因为要寻找到不大于中值(即a[mid]=1)的值，因此j--直到j=2

此时i>=j因此不进行交换且结束循环，进入递归；进入递归前可发现大于中值的在中值的右边，小于中值的在中值左边；

记住此时的i=3,j=2;

先从左边递归，即在i=1和j=2之间排列；中值为0；需要寻找大于或小于中值的数，此时i=2,j=1;说明不需要进行交换，并且此时i和j已经为这部分区间的边界，即这部分已经排列完成；

接着返回上一步，从右边进行递归，即在i=3和j=10之间进行排列；

取中值mid=6，即a[mid]=3;

进行寻找大于和小于中值的值，即i=3,j=6,即a[i]=4,a[j]=3;交换a[i]与a[j]；此时数组如下

| 0   | 1   | 3   | 6   | 2   | 4   | 8   | 9   | 12  | 7   |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

进行i++与j--，此时i=4,j=5；且此时a[i]与a[j]满足交换条件，进行交换，即

| 0   | 1   | 3   | 2   | 6   | 4   | 8   | 9   | 12  | 7   |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

进行i++与j--；此时i=5,j=4，退出循环；在l=3(未排列数组的左边界)和j=4之间进行递归

进行循环寻找，交换数值，此时数组如下

| 0   | 1   | 2   | 3   | 6   | 4   | 8   | 9   | 12  | 7   |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

此时的i与j到达边界，返回上一步递归；

进行右边的递归，即i=5,j=10；

进行寻找，取中值mid=7,a[mid]=8,寻找大于小于中值的数，此时i=7,j=10,a[i]=8,a[j]=7;进行交换，数组如下

| 0   | 1   | 2   | 3   | 6   | 4   | 7   | 9   | 12  | 8   |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

进行i++与j--；此时i=8,j=9;寻找符合的i与j，最后i=8,j=7,不进行交换，进入递归；

先左边递归，i=5,j=7;mid=6,a[mid]=4;

进行交换时i=5,j=6;数组如下；

| 0   | 1   | 2   | 3   | 4   | 6   | 7   | 9   | 12  | 8   |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

到达边界，返回上一步；

进行右边递归，i=8,j=10;取中值mid=9,a[mid]=12；

进行交换时i=9，j=10；交换后如下

| 0   | 1   | 2   | 3   | 4   | 6   | 7   | 9   | 8   | 12  |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

i++和j--后，i=10,j=9；接着推出循环。左边递归；

此时i=8,j=9;取中值mid=8,a[mid]=9寻找相应数，进行交换，此时i=8,j=9;交换后

| 0   | 1   | 2   | 3   | 4   | 6   | 7   | 8   | 9   | 12  |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

排列完成，结束退出；

### 具体代码（C语言）

#include <stdio.h>
int a[1024];
void Quick_Sort(int l,int r){
    int i,j,mid,p;
    i=l,j=r,mid=a[(l+r)/2];
    do{
        while(a[i]<mid)i++;
        while(a[j]>mid)j--;
        if(i<=j){
            p=a[i],a[i]=a[j],a[j]=p;
            i++,j--;
        }
    }while(i<=j);
    if(l<j)ch(l,j);
    if(i<r)ch(i,r);
}
int main(){
    int n;
    printf("输入要输入的数的数量\n");
    scanf("%d",&n); 
    printf("输入数字\n");
     for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    Quick_Sort(1,n);
     for(int i=1;i<=n;i++){
         printf("%d ",a[i]); 
     }
     return 0; 
}
