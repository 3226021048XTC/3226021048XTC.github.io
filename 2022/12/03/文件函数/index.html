<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>文件函数 · Hexo</title><meta name="description" content="一.fopen()函数1234567typedef struct&amp;#123; int fd; //文件号 int cleft; //缓冲区中剩下的字符数 int _ode; //文件操作方式 char *next; //文件当前读写位置 char *buff; //文件缓冲区位置&amp;#125;FILE"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hexo</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>文件函数</a></h3></div><div class="post-content"><h3 id="一-fopen-函数"><a href="#一-fopen-函数" class="headerlink" title="一.fopen()函数"></a>一.fopen()函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 系统打开文件时定义的结构体">typedef struct<br>&#123; int fd; //文件号<br> int cleft; //缓冲区中剩下的字符数<br> int _ode; //文件操作方式<br> char *next; //文件当前读写位置<br> char *buff; //文件缓冲区位置<br>&#125;FILE;<br></code></pre></td></tr></table></figure>
<p>使用：<strong>FILE  <em>fp=fopen(“char  </em>name”, “char *mode”);</strong></p>
<p><strong>name</strong> 表示文件的文件名(可以包含路径)，<strong>*mode</strong> 表示打开的方式；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mode打开方式">r：以只读方式打开文件，该文件必须存在;<br>r+：以读/写方式打开文件，该文件必须存在;<br>rb+：以读/写方式打开一个二进制文件，只允许读/写数据;<br>rt+：以读/写方式打开一个文本文件，允许读和写;<br>w：打开只写文件，若文件存在则文件长度清为零(相当与删除原文件，重新建立一个同名新文件)；<br>若文件不存在则创建该文件;<br>w+：打开可读/写文件，(类似w和r+的结合)若文件存在则文件长度清为零，即该文件内容会消失；<br>若文件不存在则创建该文件；<br>a：以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会<br>被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）；<br>a+：以附加方式打开可读/写的文件。(相当于a和r+的结合)若文件不存在，则会创建该文件，<br>如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）；<br>wb：以只写方式打开或新建一个二进制文件，只允许写数据;<br>wb+：以读/写方式打开或新建一个二进制文件，允许读和写;<br>wt+：以读/写方式打开或新建一个文本文件，允许读和写;<br>at+：以读/写方式打开一个文本文件，允许读或在文本末追加数据;<br>ab+：以读/写方式打开一个二进制文件，允许读或在文件末追加数据。<br>(打开方式不表明是t或者b时，默认为t)<br></code></pre></td></tr></table></figure>
<p>fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，当文件打开失败时返回一个空指针(NULL)，成功则返回该结构体地址；在打开文件时一定要判断文件是否打开成功，因为一旦打开失败，后续操作就都没法进行了，往往以“结束程序”告终。</p>
<p>文件使用完毕要关闭函数:</p>
<p><strong>int fclose(FILE *fp)</strong> 正常关闭时返回0，返回非0时表示出错；</p>
<p><strong>fp=NULL</strong> 指针需要指向空地址，否则依然指向文件的地址；</p>
<h3 id="二-feof-函数"><a href="#二-feof-函数" class="headerlink" title="二. feof()函数"></a>二. feof()函数</h3><p>feof()一般用来判断一个文件是否结束，如果文件结束，则返回非0值，否则返回0；</p>
<p>对于这个函数有一个经典错误，那就是关于EOF；</p>
<p>EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取，资料源通常称为档案或串流，通常在文本的最后存在此字符表示资料结束。</p>
<p>即在文件的结尾包含EOF这个内容，其值通常为-1，在不同的系统值可能有所不同；</p>
<p>对于feof()来说，并不是通过读到EOF来判断文件是否为空，而是读取文件中输入光标后面是否有内容来判断文件是否为空，而一个文件即使没有输入数据，文件中也有EOF作为内容表示文件资料结束，因此feof()使用时站在光标后面观察是否有数据时看见了EOF自然就判断文件不为空；</p>
<p>getc(FILE *name)，通过这个函数从文件中读取一个内容字符，让光标后移一个字符，让光标移动到EOF后面，这个时候在判断文件是否为空；</p>
<p>注意使用这个函数后要在使用 <strong>rewind(FILE*name)</strong> 函数使光标回到文件开头部位，这样才能保住文件的正常使用；</p>
<h3 id="三-格式化读写函数"><a href="#三-格式化读写函数" class="headerlink" title="三.格式化读写函数"></a>三.格式化读写函数</h3><p>格式化读取函数：<strong>fprintf()</strong> </p>
<p>使用：<strong>fprintf(FILE <em>fp,char </em>format,····)</strong>，format表示格式控制输入字符串，····表示参数列表；</p>
<p>格式化写入函数：<strong>fscanf()</strong> </p>
<p>使用：<strong>fscanf(FILE <em>fp,,char </em>format,····)</strong>,意义同上；</p>
<p>fprintf()使用成功时返回成功写入的字符个数，失败返回负数；</p>
<p>fscanf()使用时返回参数列表中被成功赋值的参数个数；</p>
<p>如果将 fp 设置为 stdin，那么 fscanf() 函数将会从键盘读取数据，与 scanf 的作用相同；设置为 stdout，那么 fprintf() 函数将会向显示器输出内容，与 printf 的作用相同。</p>
<h3 id="四-字符读写函数"><a href="#四-字符读写函数" class="headerlink" title="四.字符读写函数"></a>四.字符读写函数</h3><p>字符读取函数：<strong>fgetc()</strong>;</p>
<p>fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符；</p>
<p>使用：<strong>fgetc(FILE *fp)</strong>,</p>
<p>成功时返回读取到的字符；</p>
<p>注意：在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。  </p>
<p>字符写入函数：<strong>fputc()</strong>;</p>
<p>fputc 是 file output char 的缩写，意思是向指定的文件中写入一个字符；</p>
<p>使用：<strong>fputc(char c,FILE *fp)</strong>,</p>
<p>fputc() 写入成功时返回写入的字符，失败时返回 EOF;</p>
<h6 id="两点说明"><a href="#两点说明" class="headerlink" title="两点说明:"></a>两点说明:</h6><p>1) 被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。  </p>
<p>2) 每写入一个字符，文件内部位置指针向后移动一个字节。</p>
<h3 id="五-数据块读写函数"><a href="#五-数据块读写函数" class="headerlink" title="五.数据块读写函数"></a>五.数据块读写函数</h3><p>C语言提供了用于整块数据的读写函数。可用来读一组数据，如一个数组元素，一个结构变量的值等；</p>
<p>数据块读取函数：<strong>fread(void <em> p,size</em>number,count,FILE *fp)</strong> ;</p>
<p>数据块写入函数：<strong>fwrite(void <em> p,size</em>number,count,FILE *fp)</strong></p>
<p>指针p表示存放输出数据/存放输入数据的首地址，size*number表示数据块字节数，count表示读取/输入的数据块块数，fp表示文件指针；函数返回读取到/写入的元素个数；</p>
<p>此函数一般用于二进制文件的输入和输出；</p>
<h3 id="六-字符串读写函数"><a href="#六-字符串读写函数" class="headerlink" title="六.字符串读写函数"></a>六.字符串读写函数</h3><p>字符串写入函数:<strong>fputs(const char <em>s, FILE </em>fp)</strong></p>
<p>其中，s是要写入的字符串，fp是文件指针；将字符串s输入至fp所指向的文件（不含’\0’）。如果成功，位置指针自动后移，函数返回最后写入的一个字符；否则返回EOF。</p>
<p>字符串读取函数;<strong>fgets(char <em>s， int n， FILE </em>fp)</strong></p>
<p>其中，s指向待赋值字符串的首地址，n是控制读取个数的参数，fp为文件指针；</p>
<p>从位置指针开始读取 一行或n-1个字符，并存入s，存储时自动在字符串结尾加上’\0’。如果函数执行成功，位置指针自动后移，并返回字符串s的首地址，否则返回NULL。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-12-03</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2022/12/03/文件函数/,Hexo,文件函数,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/11/24/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/" title="变量与相关关键字">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"left","width":300,"height":600,"hOffset":-15,"vOffset":-15},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>