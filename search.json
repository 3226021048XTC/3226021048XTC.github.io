[{"title":"C语言划水日记（1）","url":"/2022/09/28/C%E8%AF%AD%E8%A8%80%E5%88%92%E6%B0%B4%E6%97%A5%E8%AE%B0%EF%BC%881%EF%BC%89/","content":"<h1 id=\"一：基本数据类型的分类\"><a href=\"#一：基本数据类型的分类\" class=\"headerlink\" title=\"一：基本数据类型的分类\"></a>一：基本数据类型的分类</h1><h2 id=\"1-整形\"><a href=\"#1-整形\" class=\"headerlink\" title=\"1.整形\"></a>1.整形</h2><h3 id=\"有符号数：\"><a href=\"#有符号数：\" class=\"headerlink\" title=\"有符号数：\"></a>有符号数：</h3><h5 id=\"1-short-int或short：-32768-32767-2-15-2-15-1\"><a href=\"#1-short-int或short：-32768-32767-2-15-2-15-1\" class=\"headerlink\" title=\"(1)short int或short：-32768~32767(2^15~2^15 -1)\"></a>(1)short int或short：-32768~32767(2^15~2^15 -1)</h5><h5 id=\"2-int-2147483648-2147483647（-2-31-2-31-1）\"><a href=\"#2-int-2147483648-2147483647（-2-31-2-31-1）\" class=\"headerlink\" title=\"(2)int: -2147483648~2147483647（-2^31~2^31 -1）\"></a>(2)int: -2147483648~2147483647（-2^31~2^31 -1）</h5><h5 id=\"3-long-int或long-2147483648-2147483647（-2-31-2-31-1）\"><a href=\"#3-long-int或long-2147483648-2147483647（-2-31-2-31-1）\" class=\"headerlink\" title=\"(3)long int或long: -2147483648~2147483647（-2^31~2^31-1）\"></a>(3)long int或long: -2147483648~2147483647（-2^31~2^31-1）</h5><h3 id=\"无符号数\"><a href=\"#无符号数\" class=\"headerlink\" title=\"无符号数\"></a>无符号数</h3><h5 id=\"1-unsigned-short-0-65535（0-2-16-1）\"><a href=\"#1-unsigned-short-0-65535（0-2-16-1）\" class=\"headerlink\" title=\"(1)unsigned short: 0~65535（0~2^16-1）\"></a>(1)unsigned short: 0~65535（0~2^16-1）</h5><h5 id=\"2-unsigned-0-4294967295（0-2-32-1）\"><a href=\"#2-unsigned-0-4294967295（0-2-32-1）\" class=\"headerlink\" title=\"(2)unsigned: 0~4294967295（0~2^32-1）\"></a>(2)unsigned: 0~4294967295（0~2^32-1）</h5><h5 id=\"3-unsigned-long-0-4294967295（0-2-32-1）\"><a href=\"#3-unsigned-long-0-4294967295（0-2-32-1）\" class=\"headerlink\" title=\"(3)unsigned long: 0~4294967295（0~2^32-1）\"></a>(3)unsigned long: 0~4294967295（0~2^32-1）</h5><h2 id=\"2-浮点型\"><a href=\"#2-浮点型\" class=\"headerlink\" title=\"2.浮点型\"></a>2.浮点型</h2><h5 id=\"1-单-精-度-float-3-4E-38～3-4E-38-7位有效数字\"><a href=\"#1-单-精-度-float-3-4E-38～3-4E-38-7位有效数字\" class=\"headerlink\" title=\"(1)单 精 度: float: -3.4E-38～3.4E+38   7位有效数字\"></a>(1)单 精 度: float: -3.4E-38～3.4E+38   7位有效数字</h5><h5 id=\"1-双-精-度-double-1-7E-308～1-7E-308-16位有效数字\"><a href=\"#1-双-精-度-double-1-7E-308～1-7E-308-16位有效数字\" class=\"headerlink\" title=\"(1)双 精 度: double: -1.7E-308～1.7E+308   16位有效数字\"></a>(1)双 精 度: double: -1.7E-308～1.7E+308   16位有效数字</h5><h5 id=\"1-长双精度-long-double-3-4E-308～3-4E-308-19位有效数字\"><a href=\"#1-长双精度-long-double-3-4E-308～3-4E-308-19位有效数字\" class=\"headerlink\" title=\"(1)长双精度: long double: -3.4E-308～3.4E+308   19位有效数字\"></a>(1)长双精度: long double: -3.4E-308～3.4E+308   19位有效数字</h5><h2 id=\"3-字符型\"><a href=\"#3-字符型\" class=\"headerlink\" title=\"3.字符型\"></a>3.字符型</h2><h5 id=\"1-字符：-char\"><a href=\"#1-字符：-char\" class=\"headerlink\" title=\"(1)字符： char\"></a>(1)字符： char</h5><h1 id=\"二：常量和变量\"><a href=\"#二：常量和变量\" class=\"headerlink\" title=\"二：常量和变量\"></a>二：常量和变量</h1><h4 id=\"常量定义：\"><a href=\"#常量定义：\" class=\"headerlink\" title=\"常量定义：\"></a>常量定义：</h4><p>程序运行时其值不能改变的量（即常数）</p>\n<h4 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类:\"></a>分类:</h4><h4 id=\"符号常量-用标识符代表常量定义格式：-define-符号常量-常量\"><a href=\"#符号常量-用标识符代表常量定义格式：-define-符号常量-常量\" class=\"headerlink\" title=\"符号常量:   用标识符代表常量定义格式： #define   符号常量   常量\"></a>符号常量:   用标识符代表常量定义格式： #define   符号常量   常量</h4><h4 id=\"直接常量\"><a href=\"#直接常量\" class=\"headerlink\" title=\"直接常量:\"></a>直接常量:</h4><p>​    整型常量   实型常量    字符常量   字符串常量</p>\n<h4 id=\"字符常量：用单引号括起来的单个普通字符或转义字符\"><a href=\"#字符常量：用单引号括起来的单个普通字符或转义字符\" class=\"headerlink\" title=\"字符常量：用单引号括起来的单个普通字符或转义字符\"></a>字符常量：用单引号括起来的单个普通字符或转义字符</h4><h4 id=\"字符常量的值：该字符的ASCII码值\"><a href=\"#字符常量的值：该字符的ASCII码值\" class=\"headerlink\" title=\"字符常量的值：该字符的ASCII码值\"></a>字符常量的值：该字符的ASCII码值</h4><h4 id=\"转义字符-反斜线后面跟一个字符或一个代码值表示\"><a href=\"#转义字符-反斜线后面跟一个字符或一个代码值表示\" class=\"headerlink\" title=\"转义字符:反斜线后面跟一个字符或一个代码值表示\"></a>转义字符:反斜线后面跟一个字符或一个代码值表示</h4><p>\\n:换行；                                       \\t:水平制表: </p>\n<p>\\v:垂直制表;                                   \\b:退格; </p>\n<p>\\r:回车;                                            \\f:换页; </p>\n<p>\\a:响铃;                                            \\\\:反斜线; </p>\n<p>\\‘:单引号;                                          \\“:双引号; </p>\n<p> \\ddd：3位8进制数代表的字符； \\xhh： 2位16进制数代表的字符；</p>\n<h4 id=\"字符串常量\"><a href=\"#字符串常量\" class=\"headerlink\" title=\"字符串常量:\"></a>字符串常量:</h4><p>定义：用双引号(“”)括起来的字符序列</p>\n<p>存储：每个字符串尾自动加一个 ‘\\0’ 作为字符</p>\n<h2 id=\"变量概念：其值可以改变的量\"><a href=\"#变量概念：其值可以改变的量\" class=\"headerlink\" title=\"变量概念：其值可以改变的量\"></a>变量概念：其值可以改变的量</h2><h4 id=\"变量三要素：变量名、变量类型和变量值\"><a href=\"#变量三要素：变量名、变量类型和变量值\" class=\"headerlink\" title=\"变量三要素：变量名、变量类型和变量值\"></a>变量三要素：变量名、变量类型和变量值</h4><h4 id=\"变量定义的一般格式：-数据类型-变量1-，变量2，…，变量n\"><a href=\"#变量定义的一般格式：-数据类型-变量1-，变量2，…，变量n\" class=\"headerlink\" title=\"变量定义的一般格式：     数据类型  变量1[，变量2，…，变量n];\"></a>变量定义的一般格式：     数据类型  变量1[，变量2，…，变量n];</h4><h3 id=\"常变量-const-数据类型-常变量名-初始值\"><a href=\"#常变量-const-数据类型-常变量名-初始值\" class=\"headerlink\" title=\"常变量: const 数据类型 常变量名=初始值\"></a>常变量: const 数据类型 常变量名=初始值</h3>","tags":["3"]},{"title":"Hello World","url":"/2022/12/04/hello-world/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">mathjax: true<br></code></pre></td></tr></table></figure>\n<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"宏定义","url":"/2022/11/22/%E5%AE%8F%E5%AE%9A%E4%B9%89/","content":"<h1 id=\"无参宏：宏名后不带参数\"><a href=\"#无参宏：宏名后不带参数\" class=\"headerlink\" title=\"无参宏：宏名后不带参数\"></a>无参宏：宏名后不带参数</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs #define\">#define 宏名 替代的文本<br></code></pre></td></tr></table></figure>\n<p>每个#define行（即逻辑行）由三部分组成：</p>\n<p>第一部分是指令 <strong>#define</strong> 自身，“<strong>#</strong>”表示这是一条预处理命令，“<strong>define</strong>”为宏命令；</p>\n<p>第二部分为宏，一般为缩略语，其名称（宏名）一般大写，而且不能有空格，遵循C变量命令规则。“替换文本”可以是任意常数、表达式、字符串等；</p>\n<p>第三部分是替换的文本，在预处理工作过程中，代码中所有出现的“宏名”，都会被“替换的文本”替换。这个替换的过程被称为“宏代换”或“宏展开”。“宏代换”是由预处理程序自动完成的。在C语言中，“宏”分为两种：无参数 和 有参数。</p>\n<p>“<strong>#</strong>”可以不在行首，但只允许它前面有空格符；</p>\n<p> 标识符和替换列表之间不能加赋值号 =，替换列表后不能加分号；</p>\n<p>如果要写宏不止一行，则在结尾加反斜线符号使得多行能连接上，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">#define HELLO &quot;hello \\<br>the world&quot;<br></code></pre></td></tr></table></figure>\n<p>注意：行与行之间的空格也会被作为替换文本的一部分；</p>\n<p>宏名如果出现在源程序中的 “ ”（括号）内，则不会被当做宏来进行宏代换；</p>\n<p>宏可以嵌套，但不参与运算；</p>\n<p>宏定义必须写在函数之外，其作用域是 #<strong>define</strong> 开始，到源程序结束。如果要提前结束它的作用域则用 #<strong>undef 标识符</strong> 命令；</p>\n<p>可以用宏定义表示数据类型，可以使代码简便：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">#define STU struct Student      // 宏定义STU<br>struct Student&#123;                 // 定义结构体Student<br>    char *name;<br>    int sNo;<br>&#125;;<br>STU stu = &#123;&quot;Jack&quot;, 20&#125;;         // 被替换为：struct Student stu = &#123;&quot;Jack&quot;, 20&#125;;<br>printf(&quot;name: %s, sNo: %d\\n&quot;, stu.name, stu.sNo);<br></code></pre></td></tr></table></figure>\n<h1 id=\"有参宏\"><a href=\"#有参宏\" class=\"headerlink\" title=\"有参宏\"></a>有参宏</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">#define 宏名（参数，参数···） 替换主体（表达式）<br></code></pre></td></tr></table></figure>\n<p>和函数类似，在宏定义中的参数成为形式参数，在宏调用中的参数成为实际参数。</p>\n<p>而且和无参宏不同的一点是，有参宏在调用中，不仅要进行宏展开，而且还要用实参去替换形参。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> M 5                          <span class=\"hljs-comment\">//无参宏</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> COUNT(M) M * M               <span class=\"hljs-comment\">//有参宏</span></span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;COUNT = %d\\n&quot;</span>, COUNT(<span class=\"hljs-number\">10</span>));   <span class=\"hljs-comment\">// 替换为： COUNT(10) = 10 * 10</span><br>                                     <span class=\"hljs-comment\">// 输出结果： COUNT = 100</span><br></code></pre></td></tr></table></figure>\n<p>这看上去用法与函数调用类似，但实际上是有很大差别的。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> COUNT(M) M * M               <span class=\"hljs-comment\">//定义有参宏</span></span><br><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">6</span>;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;COUNT = %d\\n&quot;</span>, COUNT(x + <span class=\"hljs-number\">1</span>));<span class=\"hljs-comment\">// 输出结果： COUNT = 13</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;COUNT = %d\\n&quot;</span>, COUNT(++x));  <span class=\"hljs-comment\">// 输出结果： COUNT = 56                                                                                               //warning:... main.c:161:34: Multiple unsequenced             modifications to &#x27;x&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>这两个结果和调用函数的方法的结果差别很大，因为如果是像函数那样的话，COUNT(x + 1)应该相当于COUNT(7)，结果应该是 7 <em> 7 = 49，但输出结果却是21。原因在于，预处理器不进行技术，只是进行字符串替换，而且也不会自动加上括号（），所以COUNT(x + 1)被替换为 COUNT(x + 1 </em> x + 1)，代入 x = 6，即为 6 + 1 * 6 + 1 = 13。而解决办法则是：尽量用括号把整个替换文本及其中的每个参数括起来：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> COUNT(M) ((M) * (M))  </span><br></code></pre></td></tr></table></figure>\n<p>但即使用括号，也不能解决上面例子的最后一个情况，COUNT(++x) 被替换为 ++x <em> ++x，即为 7 </em> 8 = 56，而不是想要 7 * 7 = 49，解决办法最简单的是：不要在有参宏用使用到“++”、“–”等。</p>\n<p>上面说到宏名中不能有空格，宏名与形参表之间也不能有空格，而形参表中形参之间可以出现空格：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SUM (a,b) a + b              <span class=\"hljs-comment\">//定义有参宏</span></span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;SUM = %d\\n&quot;</span>, SUM(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>));      <span class=\"hljs-comment\">//调用有参宏。Build Failed！</span><br>因为 SUM 被替换为：(a,b) a + b<br></code></pre></td></tr></table></figure>\n<p>如果用函数求一个整数的平方，则是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">count</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>所以在宏定义中：#define COUNT(M) M * M 中的形参不分配内存单元，所以不作类型定义。而函数 int count(int x)中形参是局部变量，会在栈区分配内存单元，所以要作类型定义，而且实参与形参之间是“值传递”。而宏只是符号代换，不存在值传递。</p>\n<p>宏定义也可以用来定义表达式或者多个语句。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> JI(a,b) a = i + 3; b = j + 5;   <span class=\"hljs-comment\">//宏定义多个语句</span></span><br><span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">5</span>, j = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">0</span>, n = <span class=\"hljs-number\">0</span>;<br>JI(m, n);                               <span class=\"hljs-comment\">// 宏代换后为： m = i + 3, n = j + 5;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;m = %d, n = %d\\n&quot;</span>, m, n);       <span class=\"hljs-comment\">// 输出结果为： m = 8, n = 15</span><br></code></pre></td></tr></table></figure>\n<p><strong>3、# 运算符</strong></p>\n<p>比如如果我们宏定义了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SUM (a,b) ((a) + (b)) </span><br></code></pre></td></tr></table></figure>\n<p>我们想要输出“1 + 2 + 3 + 4 = 10”，用以下方式显得比较麻烦，有重复代码，而且中间还有括号：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;(%d + %d) + (%d + %d) = %d\\n&quot;</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, SUM(<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>+ <span class=\"hljs-number\">4</span>));<br></code></pre></td></tr></table></figure>\n<p>那么这时可以考虑用 # 运算符来在字符串中包含宏参数，# 运算符的用处就是把语言符号转化为字符串。例如，如果 a 是一个宏的形参，则替换文本中的 #a 则被系统转化为 “a”。而这个转化的过程成为 “字符串化（stringizing）”。用这个方法实现上面的要求：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SUM(a,b) printf(#a <span class=\"hljs-string\">&quot; + &quot;</span>#b<span class=\"hljs-string\">&quot; = %d\\n&quot;</span>,((a) + (b)))    <span class=\"hljs-comment\">//宏定义，运用 # 运算符</span></span><br>SUM(<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span>);                                          <span class=\"hljs-comment\">//宏调用</span><br><span class=\"hljs-comment\">//输出结果：1 + 2 + 3 + 4 = 10</span><br></code></pre></td></tr></table></figure>\n<p>调用宏时，用 1 + 2 代替 a，用 3 + 4 代替b，则替换文本为：printf(“1 + 2” ” + ” “3 + 4” ” = %d\\n”,((1 + 2) + (3 + 4)))，接着字符串连接功能将四个相邻的字符串转换为一个字符串：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-string\">&quot;1 + 2 + 3 + 4 = %d\\n&quot;</span><br></code></pre></td></tr></table></figure>\n<p><strong>4、## 运算符</strong></p>\n<p>和 # 运算符一样，## 运算符也可以用在替换文本中，而它的作用是起到粘合的作用，即将两个语言符号组合成一个语言符号，所以又称为“预处理器的粘合剂（Preprocessor Glue）”。用法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> NAME(n) num ## n            <span class=\"hljs-comment\">//宏定义，使用 ## 运算符</span></span><br><span class=\"hljs-type\">int</span> num0 = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;num0 = %d\\n&quot;</span>, NAME(<span class=\"hljs-number\">0</span>));     <span class=\"hljs-comment\">//宏调用</span><br></code></pre></td></tr></table></figure>\n<p>NAME(0)被替换为 num ## 0，被粘合为： num0。</p>\n<p><strong>5、可变宏：… 和 <strong>VA_ARGS</strong></strong></p>\n<p>我们经常要输出结果时要多次使用 prinf(“…”, …); 如果用上面例子#define SUM(a,b) printf(#a ” + “#b” = %d\\n”,((a) + (b)))，则格式比较固定，不能用于输出其他格式。</p>\n<p>这时我们可以考虑用可变宏（Variadic Macros）。用法是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PR(...) printf(__VA_ARGS__)     <span class=\"hljs-comment\">//宏定义</span></span><br>PR(<span class=\"hljs-string\">&quot;hello\\n&quot;</span>);                          <span class=\"hljs-comment\">//宏调用</span><br><span class=\"hljs-comment\">//输出结果：hello</span><br></code></pre></td></tr></table></figure>\n<p>在宏定义中，形参列表的最后一个参数为省略号“…”，而“<strong>VA_ARGS</strong>”就可以被用在替换文本中，来表示省略号“…”代表了什么。而上面例子宏代换之后为： printf(“hello\\n”);</p>\n<p>还有个例子如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PR2(X, ...) printf(<span class=\"hljs-string\">&quot;Message&quot;</span>#X<span class=\"hljs-string\">&quot;:&quot;</span>__VA_ARGS__)   <span class=\"hljs-comment\">//宏定义</span></span><br><span class=\"hljs-type\">double</span> msg = <span class=\"hljs-number\">10</span>;<br>PR2(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;msg = %.2f\\n&quot;</span>, msg);                            <span class=\"hljs-comment\">//宏调用</span><br><span class=\"hljs-comment\">//输出结果：Message1:msg = 10.00</span><br></code></pre></td></tr></table></figure>\n<p>在宏调用中，X的值为1，所以 #X 被替换为”1”。宏代换后为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Message&quot;</span><span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-string\">&quot;:&quot;</span><span class=\"hljs-string\">&quot;msg = %.2f\\n&quot;</span>, msg);<br></code></pre></td></tr></table></figure>\n<p>接着这4个字符串连接成一个：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Message1:msg = %.2f\\n&quot;</span>, msg);<br></code></pre></td></tr></table></figure>\n<p>要注意的是：省略号“…”只能用来替换宏的形参列表中最后一个！</p>\n"},{"title":"指针","url":"/2022/10/17/%E6%8C%87%E9%92%88/","content":"<h1 id=\"一-指针简介\"><a href=\"#一-指针简介\" class=\"headerlink\" title=\"一.指针简介\"></a>一.指针简介</h1><p>在C语言中，数据结构存储于内存空间中，而内存空间实际是一组由有序字节组成的数组，有序字节即为这些数据结构的地址名，指针的便是保存数据结构的地址的变量，通过指针便可以更方便地对这些数据结构进行操作。</p>\n<h1 id=\"二-指针变量\"><a href=\"#二-指针变量\" class=\"headerlink\" title=\"二.指针变量\"></a>二.指针变量</h1><p>和一般变量相同，指针变量先进行定义再使用；</p>\n<p>一般形式为：</p>\n<p><em>类型说明符   </em>变量名；*</p>\n<p>其中，*表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示该指针变量所指向的变量的数据类型；</p>\n<ol>\n<li><p>普通变量的定义：定义一个普通变量，在内存空间中有一块空间存储着这个变量的值，这块空间的位置叫做地址，可以用地址操作符&amp;对变量进行操作；</p>\n</li>\n<li><p>指针变量的定义：如:int *p=NULL，这里定义一个指针变量，里面存储着一个地址，现在赋值为NULL(其实就是0，表示特殊的空地址)；</p>\n</li>\n<li><p>给指针变量赋值：如：p=&amp;a 即把a的地址赋值给p，显然直接对p的存取操作的是地址 ，通过这个地址间接操作的才是普通变量(a)。</p>\n</li>\n</ol>\n<p>赋值的方式：</p>\n<p>int <em>p=&a;  或 int </em>p;p=&a;</p>\n<p>注意不能把一个数赋予指针变量，被赋值的指针变量前不能再加“*”说明符</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">说明</th>\n<th style=\"text-align:center\">例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">定义</td>\n<td style=\"text-align:center\">int a=10;  int *p;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">赋值</td>\n<td style=\"text-align:center\">p=&a;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">间接运算</td>\n<td style=\"text-align:center\">*p=10;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指针变量直接存储的是地址</td>\n<td style=\"text-align:center\">cout&lt;&lt;p; 结果可能是地址的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指针变量间接存储的是变量值</td>\n<td style=\"text-align:center\">cout&lt;&lt;*p;  结果是10</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"三-指针的引用和运算\"><a href=\"#三-指针的引用和运算\" class=\"headerlink\" title=\"三.指针的引用和运算\"></a>三.指针的引用和运算</h1><ol>\n<li>初始化：对于定义的局部指针变量，因为其内容是随机的，直接进行操作可能会破坏程序和系统内存的值，引发不可预测的错误，所以在编程中要保证先初始化或者赋值，给与正确的地址再进行使用和操作；</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>int *p=NULL</td>\n<td>NULL是特殊的地址0，叫零指针</td>\n</tr>\n<tr>\n<td>2</td>\n<td>int *p=&amp;a</td>\n<td>p初始化为a的地址</td>\n</tr>\n<tr>\n<td>3</td>\n<td>int *p=new(int)</td>\n<td>申请一个空间给p，*p的内容不确定</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li>指针变量的+与-：因为指针变量的内容是地址，其有加与减两种常用的运算，这两个运算一般与数组进行使用操作；</li>\n</ol>\n<p>特别说明，在指针变量中“p++”的意思是“广义的加1”，不是p的值(地址)加1，而是根据类型的不同增加一个sizeof(类型)，即跳过一个数据空间，达到下一个数据空间；</p>\n<ol>\n<li>多重指针:指针本身也是一种类型，即指针能够指向指针；</li>\n</ol>\n"},{"title":"指针与数组","url":"/2022/10/18/%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/","content":"<h1 id=\"一-指针与数组\"><a href=\"#一-指针与数组\" class=\"headerlink\" title=\"一.指针与数组\"></a>一.指针与数组</h1><ol>\n<li><p>数组是一块连续的内存单元，其中数组名的值就是这块连续内存的首地址；一个指针变量既可以指向一个数组，也可以指向一个数组元素；比如：指针变量p=a与a与&amp;a[0]的值是一样的，都指向数组a的首地址，也是0号元素，a[0]的地址；p+1,a+1,&amp;a[1]都指向1号元素，类似可得p+i，a+i，&amp;a[i]指向i号元素；应注意指针是变量，数组名和数组元素是常量；</p>\n</li>\n<li><p>引入指针后可用<em>(p+i)的形式访问数组a[i]的元素，下标法：通过p[i]访问a[i]的元素；指针法：</em>(p+i)访问a[i]的元素；</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">int a[5],*p=a<br>for(int i=1;i&lt;=5;i++)&#123;<br>    scanf(&quot;%d&quot;,&amp;a[i]);//a[i]与a+i和p+i等价；<br>&#125;<br>for(int i=1;i&lt;=5;i++)&#123;<br>    printf(&quot;%d&quot;,a[i]);//a[i]与*(p+i),*(a+i),p[i]等价<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>把a当指针用，a+i指向第i个元素；注意a是静态常量，是不可变的，指针是变量，可以变化，如p=p+1是合法的，a=a+1是非法的；</p>\n<ol>\n<li>指针也可以看出数组名；</li>\n</ol>\n<p>指针是可以作为动态数组进行使用的，因为指针可以动态申请空间，且如果一次性申请多个变量空间，则系统给的空间则是连续的，这种情况下便可以当成数组进行操作；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">int *a;<br>int n;<br>scanf(&quot;%d&quot;,&amp;n);<br>a=new int[n+1]；//向系统申请连续的n+1个int型的空间；<br>//a=(int *)malloc(sizeof(int)*n)<br>for(int i=1;i&lt;=n;i++)&#123;<br>    scanf(&quot;%d&quot;,&amp;a[i]);<br>&#125;<br>for(int i=1;i&lt;=n;i++)&#123;<br>    printf(&quot;%d&quot;,a[i]);<br>&#125;<br>delete []a;//释放空间<br>//free(a);<br></code></pre></td></tr></table></figure>\n"},{"title":"变量与相关关键字","url":"/2022/11/24/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/","content":"<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>作用域是指变量的有效范围，即变量可以在哪个范围以内使用；变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的</p>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><p>定义在函数内部的变量，作用域仅限于此函数内部，超出函数范围不可使用；注意函数的形参也是局部变量（Local Variable）；</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>在函数的外部定义的变量称为全局变量（Global Variable）；默认作用域是整个程序，即所有的代码文件，包括源文件（<strong>.c</strong>文件）和头文件（<strong>.h</strong>文件）;</p>\n<p>说明：在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。</p>\n<h6 id=\"如果某个函数内部局部变量和全局变量同名，则在当前函数中全局变量不起作用；\"><a href=\"#如果某个函数内部局部变量和全局变量同名，则在当前函数中全局变量不起作用；\" class=\"headerlink\" title=\"如果某个函数内部局部变量和全局变量同名，则在当前函数中全局变量不起作用；\"></a>如果某个函数内部局部变量和全局变量同名，则在当前函数中全局变量不起作用；</h6><p>变量的使用遵循就近原则，如果在当前的局部作用域中找到了同名变量，就不会再去更大的全局作用域中查找。</p>\n<h4 id=\"局部变量与全局变量\"><a href=\"#局部变量与全局变量\" class=\"headerlink\" title=\"局部变量与全局变量\"></a>局部变量与全局变量</h4><p>定义时全局变量的值为0，而局部变量的值时随机的；</p>\n<p>两者的作用域不同；</p>\n<p>全局变量分配在数据段（数据段存的是数）上，而局部变量分配在栈上面；</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p>auto：在声明局部变量时，不加关键字均默认为auto，变量与数据分配在动态存储区；</p>\n<p>static：声明时在局部变量的类型前加该关键字，表示该局部变量是“静态局部变量”，这样在函数的调用结束后该变量不会消失，即占用的内存空间不会释放，下一次函数调用时该变量的值为上一次函数结束时的值；</p>\n<p>register：在声明动态局部变量或者函数形参时，可将变量声明为register，这样编译系统就会为变量分配一个寄存器而不是内存空间，通过这种方式可提升对某些局部变量频繁调用的程序的性能。（寄存器运算速度远高于内存）</p>\n<p>extern：对于一个文件内，extern声明的变量相当于告诉编译器该变量是存在的，但不在该调用位置的前面，即定义在该调用之后，相当于扩大该变量的作用域；（真正的作用）对于不是同一个文件，可以引用不是同一个文件的变量（需为全局变量）和函数，另外extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，而关于函数的引用，需要注意的就是，需要指明返回值的类型和参数。</p>\n<h4 id=\"静态变量与动态变量\"><a href=\"#静态变量与动态变量\" class=\"headerlink\" title=\"静态变量与动态变量\"></a>静态变量与动态变量</h4><p>定义或者声明变量时，没有static修饰符的就是动态变量，有static修饰符的就是静态变量；</p>\n<p><strong>静态全局变量</strong>：动态全局变量可以通过extern关键字在外部文件中使用，但静态全局变量不可以在外部文件中使用，静态全局变量相当于限制了动态全局变量的作用域。</p>\n<p><strong>静态局部变量</strong>：静态局部变量的生命周期是到程序的结束，而动态局部变量的生命周期是函数的结束，静态局部变量的生命周期更长，同时静态局部变量只会初始化一次，函数重复调用，但静态局部变量不会被重新初始化。</p>\n"},{"title":"指针动态数组（1）","url":"/2022/10/25/%E6%8C%87%E9%92%88%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84(1)/","content":"<h1 id=\"malloc函数\"><a href=\"#malloc函数\" class=\"headerlink\" title=\"malloc函数\"></a>malloc函数</h1><ol>\n<li><p>头文件：#include <malloc.h>；</p>\n</li>\n<li><p>使用：(void <em>)malloc(sizeof(void)</em>num);</p>\n</li>\n</ol>\n<p>其中void指示类型，sizeof是计算一个这个类型需要的字节，*num表示需要多少个这个类型的字节的空间，malloc后面的括号内也可以直接用数字填入，表示需要多少个字节的空间；</p>\n<ol>\n<li><p>成功返回分配空间的首地址，不成功则返回空指针NULL；</p>\n</li>\n<li><p>当内存不再使用时应使用free()函数将内存块释放掉；</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">#include&lt;malloc.h&gt;<br>int *a;<br>int n;<br>a=(int *)malloc(sizeof(int)*n)<br></code></pre></td></tr></table></figure>\n<h1 id=\"free函数\"><a href=\"#free函数\" class=\"headerlink\" title=\"free函数\"></a>free函数</h1><ol>\n<li><p>头文件：free函数头文件和malloc函数一致，即<malloc.h>;</p>\n</li>\n<li><p>使用：free(a);a=NULL;</p>\n</li>\n</ol>\n<p>free后要将指针指向NULL，避免成为野指针；因为free是将指针所指向的那片内存清除，但是指针所指向的地址仍然是相同的，如果不对指针进行处理，指针将会成为野指针；</p>\n<h1 id=\"calloc函数\"><a href=\"#calloc函数\" class=\"headerlink\" title=\"calloc函数\"></a>calloc函数</h1><ol>\n<li><p>头文件：#include<stdlib.h>或者#include <malloc.h>;</p>\n</li>\n<li><p>使用:(void *)calloc(num,sizeof(void));</p>\n</li>\n</ol>\n<p>calloc函数与free函数配套使用，calloc函数与malloc函数几乎相同，返回类型为空指针；</p>\n<p>num表示需要的空间类型的数量，void表示需要的类型，</p>\n<ol>\n<li>区别:malloc的使用效率更加高，因为callloc函数在申请动态空间时会将每一个字节都初始化为0；</li>\n</ol>\n<h1 id=\"realloc函数\"><a href=\"#realloc函数\" class=\"headerlink\" title=\"realloc函数\"></a>realloc函数</h1><ol>\n<li><p>头文件:#include<stdio.h>或者#include <malloc.h></p>\n</li>\n<li><p>使用:(void <em>)realloc(指针,num </em>sizeof(int)；</p>\n</li>\n<li><p>介绍:realloc是对动态内存进行扩容(即已经申请的动态空间不够使用，需要进行扩容，指针为原来的空间地址的指针，num为扩容后的大小；</p>\n</li>\n</ol>\n<p>实际上如果num比较小，即原空间后面还有空余的内存空间，并且原空间加上空闲空间等于num，则系统将直接在原内存空间后面扩容，<strong>并返回原动态空间地址</strong>；如果num比较大，原来申请的空间后面没有足够大的空间扩容，系统将重新申请一块(num<em>sizeof(void))的内存，并把原来空间的内容拷贝过去，原来空间进行free操作，因此原空间不需要进行free操作，<strong>同时返回寻找到的空间的地址</strong>;如果num非常大，系统内存申请失败，<em>*返回NULL</em></em>,原来的内存不会释放。</p>\n<p>注意：(1)如果扩容后的内存空间比原空间小，将会出现数据丢失，如果直接realloc(p, 0);相当于free(p);</p>\n<p>(2)若realloc成功，指向原内存地址的指针就成了<strong>悬挂指针</strong>，即指针指向了一块没有分配给用户使用的内存，如果再用该指针进行操作就可能发生意想不到的问题。所以在应用realloc是应当格外注意这种情况;</p>\n<p>(3)传递给realloc的[指针必须是先前通过malloc,calloc 或realloc()分配的;</p>\n<p>(4)传递的指针可以为空，等同于malloc;</p>\n<p><del>ps:还有new与delete函数，累了下次写；</del></p>\n"},{"title":"指针动态数组(2)","url":"/2022/10/27/%E6%8C%87%E9%92%88%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84(2)/","content":"<h1 id=\"new函数-分配空间\"><a href=\"#new函数-分配空间\" class=\"headerlink\" title=\"new函数(分配空间)\"></a>new函数(分配空间)</h1><p>使用格式:</p>\n<pre><code> (1)指针变量名=new 类型标识符；\n (2)指针变量名=new 类型标识符(初始值)；\n (3)指针变量吗=new 类型标识符[内存单元个数]；\n</code></pre><p>对于(1)申请<strong>一个</strong>类型标识符大小的字节空间给指针变量名，对于(2)在申请<strong>一个</strong>类型标识符的同时对申请的空间进行赋予初始值，而对于(3)则是申请一个动态数组；</p>\n<p>其中分配成功则返回对象类型的指针地址，失败会抛出异常；</p>\n<h1 id=\"delete函数-对于上面的new函数\"><a href=\"#delete函数-对于上面的new函数\" class=\"headerlink\" title=\"delete函数(对于上面的new函数)\"></a>delete函数(对于上面的new函数)</h1><p>delete函数用于回收new函数分配的内存空间</p>\n<p>其中对于单个对象的内存空间的时候用<strong>delete 指针变量名</strong> 释放空间；</p>\n<p>对于用new[]分配的一组内存空间，用<strong>delete []指针变量名</strong> 释放空间；</p>\n<h1 id=\"new函数与malloc函数的一些区别\"><a href=\"#new函数与malloc函数的一些区别\" class=\"headerlink\" title=\"new函数与malloc函数的一些区别\"></a>new函数与malloc函数的一些区别</h1><ol>\n<li><p>new是从自由存储区上动态分配空间，而malloc函数则是在堆上动态分配空间；其中自由存储区是C++的一个基于new操作符的抽象概念，即通过new函数动态申请的空间内存都为自由存储区；堆是系统的术语，是系统维护的一块特殊内存，用于内存的动态分配；关于自由存储区，不仅可以是堆，也可以是静态存储区，这取决于operator new将对象分配到哪个空间<del>(ps:目前我也不懂，以后再了解学习，嘻嘻)</del>；</p>\n</li>\n<li><p>分配成功时new返回不需要进行强制类型转换，malloc返回的时void*，需要进行强制转换类型，基于这一点new函数的安全性高于malloc函数；</p>\n</li>\n<li><p>分配失败时malloc函数返回NULL，而new函数直接抛出程序异常；</p>\n</li>\n<li><p>对于申请的内存空间大小，malloc函数需要进行计算，而new函数无需指定内存空间大小，系统会根据类型信息自行计算；</p>\n</li>\n</ol>\n"},{"title":"插入排序","url":"/2022/10/07/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","content":"<h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include \"></a>include <stdio.h></h1><p>int main(){<br>    int n;<br>    /<em>printf(“输入要输入的数的数量\\n”);<br>    scanf(“%d”,&amp;n);<br>    printf(“输入数字\\n”);</em>/<br>     n=4;<br>     int a[n+1];<br>      for(int i=1;i&lt;=n;i++)scanf(“%d”,&amp;a[i]);<br>     for(int i=1;i&lt;=n;i++){<br>         int j,t,k;<br>         for(j=i-1;j&gt;=1;j—){<br>             if(a[i]&gt;a[j])break;<br>             }<br>             if(j!=i-1){<br>                 t=a[i];<br>                 for(k=i-1;k&gt;j;k—)a[k+1]=a[k];<br>                 a[k+1]=t;<br>             }<br>     }<br>    for(int i=1;i&lt;=n;i++){<br>         printf(“%d “,a[i]);<br>     }<br>     return 0;<br>} </p>\n"},{"title":"文件函数","url":"/2022/12/03/%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0/","content":"<h3 id=\"一-fopen-函数\"><a href=\"#一-fopen-函数\" class=\"headerlink\" title=\"一.fopen()函数\"></a>一.fopen()函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs 系统打开文件时定义的结构体\">typedef struct<br>&#123; int fd; //文件号<br> int cleft; //缓冲区中剩下的字符数<br> int _ode; //文件操作方式<br> char *next; //文件当前读写位置<br> char *buff; //文件缓冲区位置<br>&#125;FILE;<br></code></pre></td></tr></table></figure>\n<p>使用：<strong>FILE  <em>fp=fopen(“char  </em>name”, “char *mode”);</strong></p>\n<p><strong>name</strong> 表示文件的文件名(可以包含路径)，<strong>*mode</strong> 表示打开的方式；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mode打开方式\">r：以只读方式打开文件，该文件必须存在;<br>r+：以读/写方式打开文件，该文件必须存在;<br>rb+：以读/写方式打开一个二进制文件，只允许读/写数据;<br>rt+：以读/写方式打开一个文本文件，允许读和写;<br>w：打开只写文件，若文件存在则文件长度清为零(相当与删除原文件，重新建立一个同名新文件)；<br>若文件不存在则创建该文件;<br>w+：打开可读/写文件，(类似w和r+的结合)若文件存在则文件长度清为零，即该文件内容会消失；<br>若文件不存在则创建该文件；<br>a：以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会<br>被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）；<br>a+：以附加方式打开可读/写的文件。(相当于a和r+的结合)若文件不存在，则会创建该文件，<br>如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）；<br>wb：以只写方式打开或新建一个二进制文件，只允许写数据;<br>wb+：以读/写方式打开或新建一个二进制文件，允许读和写;<br>wt+：以读/写方式打开或新建一个文本文件，允许读和写;<br>at+：以读/写方式打开一个文本文件，允许读或在文本末追加数据;<br>ab+：以读/写方式打开一个二进制文件，允许读或在文件末追加数据。<br>(打开方式不表明是t或者b时，默认为t)<br></code></pre></td></tr></table></figure>\n<p>fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，当文件打开失败时返回一个空指针(NULL)，成功则返回该结构体地址；在打开文件时一定要判断文件是否打开成功，因为一旦打开失败，后续操作就都没法进行了，往往以“结束程序”告终。</p>\n<p>文件使用完毕要关闭函数:</p>\n<p><strong>int fclose(FILE *fp)</strong> 正常关闭时返回0，返回非0时表示出错；</p>\n<p><strong>fp=NULL</strong> 指针需要指向空地址，否则依然指向文件的地址；</p>\n<h3 id=\"二-feof-函数\"><a href=\"#二-feof-函数\" class=\"headerlink\" title=\"二. feof()函数\"></a>二. feof()函数</h3><p>feof()一般用来判断一个文件是否结束，如果文件结束，则返回非0值，否则返回0；</p>\n<p>对于这个函数有一个经典错误，那就是关于EOF；</p>\n<p>EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取，资料源通常称为档案或串流，通常在文本的最后存在此字符表示资料结束。</p>\n<p>即在文件的结尾包含EOF这个内容，其值通常为-1，在不同的系统值可能有所不同；</p>\n<p>对于feof()来说，并不是通过读到EOF来判断文件是否为空，而是读取文件中输入光标后面是否有内容来判断文件是否为空，而一个文件即使没有输入数据，文件中也有EOF作为内容表示文件资料结束，因此feof()使用时站在光标后面观察是否有数据时看见了EOF自然就判断文件不为空；</p>\n<p>getc(FILE *name)，通过这个函数从文件中读取一个内容字符，让光标后移一个字符，让光标移动到EOF后面，这个时候在判断文件是否为空；</p>\n<p>注意使用这个函数后要在使用 <strong>rewind(FILE*name)</strong> 函数使光标回到文件开头部位，这样才能保住文件的正常使用；</p>\n<h3 id=\"三-格式化读写函数\"><a href=\"#三-格式化读写函数\" class=\"headerlink\" title=\"三.格式化读写函数\"></a>三.格式化读写函数</h3><p>格式化写入函数：<strong>fprintf()</strong> </p>\n<p>使用：<strong>fprintf(FILE <em>fp,char </em>format,····)</strong>，format表示格式控制输入字符串，····表示参数列表；</p>\n<p>格式化读取函数：<strong>fscanf()</strong> </p>\n<p>使用：<strong>fscanf(FILE <em>fp,,char </em>format,····)</strong>,意义同上；</p>\n<p>fprintf()使用成功时返回成功写入的字符个数，失败返回负数；</p>\n<p>fscanf()使用时返回参数列表中被成功赋值的参数个数；</p>\n<p>如果将 fp 设置为 stdin，那么 fscanf() 函数将会从键盘读取数据，与 scanf 的作用相同；设置为 stdout，那么 fprintf() 函数将会向显示器输出内容，与 printf 的作用相同。</p>\n<h3 id=\"四-字符读写函数\"><a href=\"#四-字符读写函数\" class=\"headerlink\" title=\"四.字符读写函数\"></a>四.字符读写函数</h3><p>字符读取函数：<strong>fgetc()</strong>;</p>\n<p>fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符；</p>\n<p>使用：<strong>fgetc(FILE *fp)</strong>,</p>\n<p>成功时返回读取到的字符；</p>\n<p>注意：在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。  </p>\n<p>字符写入函数：<strong>fputc()</strong>;</p>\n<p>fputc 是 file output char 的缩写，意思是向指定的文件中写入一个字符；</p>\n<p>使用：<strong>fputc(char c,FILE *fp)</strong>,</p>\n<p>fputc() 写入成功时返回写入的字符，失败时返回 EOF;</p>\n<h6 id=\"两点说明\"><a href=\"#两点说明\" class=\"headerlink\" title=\"两点说明:\"></a>两点说明:</h6><p>1) 被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。  </p>\n<p>2) 每写入一个字符，文件内部位置指针向后移动一个字节。</p>\n<h3 id=\"五-数据块读写函数\"><a href=\"#五-数据块读写函数\" class=\"headerlink\" title=\"五.数据块读写函数\"></a>五.数据块读写函数</h3><p>C语言提供了用于整块数据的读写函数。可用来读一组数据，如一个数组元素，一个结构变量的值等；</p>\n<p>数据块读取函数：<strong>fread(void <em> p,size</em>number,count,FILE *fp)</strong> ;</p>\n<p>数据块写入函数：<strong>fwrite(void <em> p,size</em>number,count,FILE *fp)</strong></p>\n<p>指针p表示存放输出数据/存放输入数据的首地址，size*number表示数据块字节数，count表示读取/输入的数据块块数，fp表示文件指针；函数返回读取到/写入的元素个数；</p>\n<p>此函数一般用于二进制文件的输入和输出；</p>\n<h3 id=\"六-字符串读写函数\"><a href=\"#六-字符串读写函数\" class=\"headerlink\" title=\"六.字符串读写函数\"></a>六.字符串读写函数</h3><p>字符串写入函数:<strong>fputs(const char <em>s, FILE </em>fp)</strong></p>\n<p>其中，s是要写入的字符串，fp是文件指针；将字符串s输入至fp所指向的文件（不含’\\0’）。如果成功，位置指针自动后移，函数返回最后写入的一个字符；否则返回EOF。</p>\n<p>字符串读取函数;<strong>fgets(char <em>s， int n， FILE </em>fp)</strong></p>\n<p>其中，s指向待赋值字符串的首地址，n是控制读取个数的参数，fp为文件指针；</p>\n<p>从位置指针开始读取 一行或n-1个字符，并存入s，存储时自动在字符串结尾加上’\\0’。如果函数执行成功，位置指针自动后移，并返回字符串s的首地址，否则返回NULL。</p>\n"},{"title":"快速排序","url":"/2022/10/11/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":"<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>\n<p>该方法的基本思想是：</p>\n<ul>\n<li>1．先从数列中取出一个数作为基准数。//<em>一般是中间值</em></li>\n<li>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>\n<li>3．再对左右区间重复第二步，直到各区间只有一个数。</li>\n</ul>\n<p>并且快速排序还有一个比较简单的思想，就是递归。对于每一趟排序都是一样的思想，只不过需要进行排序的数组的范围越来越小了，使用递归实现这种排序最适合不过了。</p>\n<h2 id=\"快速排序的特点及性能\"><a href=\"#快速排序的特点及性能\" class=\"headerlink\" title=\"快速排序的特点及性能\"></a>快速排序的特点及性能</h2><p>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。  </p>\n<p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 <code>O(n2)</code>，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 <code>O(nlogn)</code>，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。  </p>\n<p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 <code>O(logn)</code>，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 <code>O(n)</code>。所以我们一般认为快速排序的空间复杂度为 <code>O(logn)</code>。  </p>\n<p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。  </p>\n<p>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>取数组的中间值作为基准值， 这组数据中取中间值1为基准值，</p>\n<p>设i=1,j=10,a[i]=7,a[10]=0,mid=5,a[mid]=1;</p>\n<p>寻找比中值(a[mid]=1)大的数，即i=1;接着寻找比中值小的数，即j=10；</p>\n<p>将a[i=1]=7与a[j=10]=0交换，同时i++,j—，即此时i=2,j=9;此时数组为</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>因为i与j还未相遇，即i与J之间还可能存在需要交换的数字，重新进入循环，</p>\n<p>进入第二次交换时i=2,j=5,此时a[i]=2与a[j]=1交换，数组如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>接着进行i++与j—；此时i=3,j=4;因为要寻找到不大于中值(即a[mid]=1)的值，因此j—直到j=2</p>\n<p>此时i&gt;=j因此不进行交换且结束循环，进入递归；进入递归前可发现大于中值的在中值的右边，小于中值的在中值左边；</p>\n<p>记住此时的i=3,j=2;</p>\n<p>先从左边递归，即在i=1和j=2之间排列；中值为0；需要寻找大于或小于中值的数，此时i=2,j=1;说明不需要进行交换，并且此时i和j已经为这部分区间的边界，即这部分已经排列完成；</p>\n<p>接着返回上一步，从右边进行递归，即在i=3和j=10之间进行排列；</p>\n<p>取中值mid=6，即a[mid]=3;</p>\n<p>进行寻找大于和小于中值的值，即i=3,j=6,即a[i]=4,a[j]=3;交换a[i]与a[j]；此时数组如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>进行i++与j—，此时i=4,j=5；且此时a[i]与a[j]满足交换条件，进行交换，即</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>进行i++与j—；此时i=5,j=4，退出循环；在l=3(未排列数组的左边界)和j=4之间进行递归</p>\n<p>进行循环寻找，交换数值，此时数组如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>此时的i与j到达边界，返回上一步递归；</p>\n<p>进行右边的递归，即i=5,j=10；</p>\n<p>进行寻找，取中值mid=7,a[mid]=8,寻找大于小于中值的数，此时i=7,j=10,a[i]=8,a[j]=7;进行交换，数组如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>进行i++与j—；此时i=8,j=9;寻找符合的i与j，最后i=8,j=7,不进行交换，进入递归；</p>\n<p>先左边递归，i=5,j=7;mid=6,a[mid]=4;</p>\n<p>进行交换时i=5,j=6;数组如下；</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>到达边界，返回上一步；</p>\n<p>进行右边递归，i=8,j=10;取中值mid=9,a[mid]=12；</p>\n<p>进行交换时i=9，j=10；交换后如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>i++和j—后，i=10,j=9；接着推出循环。左边递归；</p>\n<p>此时i=8,j=9;取中值mid=8,a[mid]=9寻找相应数，进行交换，此时i=8,j=9;交换后</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>排列完成，结束退出；</p>\n<h3 id=\"具体代码（C语言）\"><a href=\"#具体代码（C语言）\" class=\"headerlink\" title=\"具体代码（C语言）\"></a>具体代码（C语言）</h3><h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include \"></a>include <stdio.h></h1><p>int a[1024];<br>void Quick_Sort(int l,int r){<br>    int i,j,mid,p;<br>    i=l,j=r,mid=a[(l+r)/2];<br>    do{<br>        while(a[i]<mid)i++;\n        while(a[j]>mid)j—;<br>        if(i&lt;=j){<br>            p=a[i],a[i]=a[j],a[j]=p;<br>            i++,j—;<br>        }<br>    }while(i&lt;=j);<br>    if(l&lt;j)ch(l,j);<br>    if(i&lt;r)ch(i,r);<br>}<br>int main(){<br>    int n;<br>    printf(“输入要输入的数的数量\\n”);<br>    scanf(“%d”,&amp;n);<br>    printf(“输入数字\\n”);<br>     for(int i=1;i&lt;=n;i++)scanf(“%d”,&amp;a[i]);<br>    Quick_Sort(1,n);<br>     for(int i=1;i&lt;=n;i++){<br>         printf(“%d “,a[i]);<br>     }<br>     return 0;<br>}</p>\n"},{"title":"汇编语言note(补)","url":"/2023/04/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note(%E8%A1%A5)/","content":"<p>补充：OPD指目标操作数，OPS指源操作数；reg指寄存器，sreg指段寄存器，mem指内存单元，imm指立即数</p>\n<p>调试程序DEBUG中的表达标志状态</p>\n<p>溢出OV（overflow，OF＝1）</p>\n<p>无溢出NV（no overflow，OF＝0）</p>\n<p>减量DN（direction down，DF＝1）</p>\n<p>增量UP（direction up，DF＝0）</p>\n<p>允许中断EI（enable interrupt，IF＝1）</p>\n<p>进制中断DI（disable interrupt，IF＝0）</p>\n<p>负NG（negative，SF＝1）</p>\n<p>正PL（plus，SF＝0）</p>\n<p>零ZR（zero，ZF＝1）</p>\n<p>非零NZ（no zero，ZF＝0）</p>\n<p>辅助进位AC（auxiliary carry，AF＝1）</p>\n<p>无辅助进位NA（no auxiliary carry，AF＝0）</p>\n<p>偶校验PE（even parity，PF＝1）</p>\n<p>奇校验PO（odd parity，PF＝0）</p>\n<p>进位CY（carry，CF＝1）</p>\n<p>无进位NC（no carry，CF＝0）</p>\n<p>设置 nv(清除) ov(溢出)</p>\n<p>　　方向 dn(减) up(增)</p>\n<p>　　中断 ei(启用) di(禁用)</p>\n<p>　　正负 ng(负) pl(正)</p>\n<p>　　零 zr(0) nz(非0)</p>\n<p>　　辅助进位 ac(进位) na(不进位)</p>\n<p>　　奇偶校验 pe(偶校验) po(奇校验)</p>\n<p>　　进位 cy(进位) nc(不进位)</p>\n"},{"title":"时间复杂度与空间复杂度","url":"/2022/10/13/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","content":"<p>在数据结构和算法中，因为算法本身是不分“好坏”的，而所谓“最好”的算法，则是指最适合当前场景的算法。因此通常考虑程序的执行效率和占用的内存空间，即时间复杂度和空间复杂度，时间复杂度用来表示算法运行时间，空间复杂度用来表示算法所使用的空间。</p>\n<p>通常用O来表示复杂度；</p>\n<p>对于空间复杂度，在一个执行的程序中，占用的内存空间主要包括：</p>\n<p>1.程序代码本身所占用的存储空间；</p>\n<p>2.如果需要输入输出数据，也会占用一定的存储空间；</p>\n<p>3.运行过程中，可能还需要临时申请更多的存储空间。</p>\n<p>对于第一点，可以通过在编写代码的同时在保证功能的前提下，尽可能的编写足够短的代码；</p>\n<p>对于第二点，程序运行过程中输入输出的数据，往往由要解决的问题而定，即便所用算法不同，程序输入输出所占用的存储空间也是相近的。</p>\n<p>对于第三点，在程序运行过程中临时申请的内存空间，不同算法编写出的程序，运行时申请的临时存储空间通常会有较大不同，因此根据不同的情况编写合适的代码，可以减少空间复杂度；</p>\n<p>空间复杂度的估算方法是：</p>\n<ul>\n<li>如果算法中额外申请的内存空间不受用户输入值的影响（即一个固定值），那么该算法的空间复杂度用<code>O(1)</code>表示；</li>\n<li>如果随着输入值 n 的增大，算法申请的存储空间成线性增长，则程序的空间复杂度用<code>O(n)</code>表示;</li>\n<li>如果随着输入值 n 的增大，程序申请的存储空间成 n^2 关系增长，则程序的空间复杂度用<code>O(n^2)</code>表示；</li>\n<li>如果随着输入值 n 的增大，程序申请的存储空间成 n^3 关系增长，则程序的空间复杂度用<code>O(n^3)</code>表示；</li>\n</ul>\n<p>大多数情况下，一个好的程序更注重时间复杂度，空间复杂度在一个合理范围即可；</p>\n<p>对于时间复杂度，即预估算法的执行时间；</p>\n<p>计算一个算法的时间复杂度，需要经过以下 3 个步骤：</p>\n<h4 id=\"1-统计算法中各个步骤的执行次数\"><a href=\"#1-统计算法中各个步骤的执行次数\" class=\"headerlink\" title=\"1) 统计算法中各个步骤的执行次数\"></a>1) 统计算法中各个步骤的执行次数</h4><h4 id=\"2-简化算法的执行次数\"><a href=\"#2-简化算法的执行次数\" class=\"headerlink\" title=\"2) 简化算法的执行次数\"></a>2) 简化算法的执行次数</h4><h4 id=\"3-用大O记法表示算法的时间复杂度\"><a href=\"#3-用大O记法表示算法的时间复杂度\" class=\"headerlink\" title=\"3) 用大O记法表示算法的时间复杂度\"></a>3) 用大O记法表示算法的时间复杂度</h4><p>在简化中，以 3<em>n2+4</em>n+5 为例，简化过程为：</p>\n<ol>\n<li>当 n 无限大时，3n^2+4n 与 3<em>n^2+4</em>n+5 的值非常接近，是否加 5 对表达式的值影响不大，因此表达式可以简化为 3<em>n^2+4</em>n；</li>\n<li>当 n 无限大时，3<em>n^2 的值要远远大于 4</em>n 的值，它们之间类似于 10000 和 1 之间的关系，因此是否加 4<em>n 对表达式最终的值影响不大，整个表达式可以简化为 3</em>n^2；</li>\n<li>当 n 无限大时，n^2 的值已经超级大，是否乘 3 对最终结果影响不大，整个表达式可以简化为  n^2。</li>\n</ol>\n<p>基于“n 值无限大”的思想，3<em>n^2+4</em>n+5 最终就简化成了 n^2。</p>\n<p>一般情况下的时间复杂度之间大小有以下关系</p>\n<p>O(1)&lt; O(logn) &lt; O(n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)</p>\n<p>其中<code>O(1)</code>是最小的，对应的算法的执行时间最短，执行效率最高。</p>\n<p>最后在实际过程，往往采用 “预先估值”的方法挑选算法。具体来讲，就是分析各个算法的实现过程（步骤），估算出它们各自的运行时间和占用的内存大小，就可以挑选出“最好”的算法。</p>\n"},{"title":"汇编语言note.1","url":"/2023/03/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note.1/","content":"<h1 id=\"汇编语言note-1\"><a href=\"#汇编语言note-1\" class=\"headerlink\" title=\"汇编语言note.1\"></a>汇编语言note.1</h1><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h1><h4 id=\"一：基础知识\"><a href=\"#一：基础知识\" class=\"headerlink\" title=\"一：基础知识\"></a>一：基础知识</h4><ol>\n<li><p>计算机系统由硬件系统（物质实体总和）和软件系统（可运行程序总和）组成；</p>\n</li>\n<li><p>计算机的硬件部分由5大部分组成：<u>输入设备，存储器，运算器，控制器，输出设备</u>组成；</p>\n</li>\n<li><p>5大部分之间通过<u>地址总线(Address Bus)，数据总线(Date Bus)，控制总线(Control Bus)</u>连接；</p>\n</li>\n<li><p>存储器：用于存储指令和数据，分为主存储器和辅助存储器：</p>\n</li>\n</ol>\n<p>主存储器：即主存或内存，包括随机读写存储器RAM和只读存储器ROM；</p>\n<p>辅助存储器：即外存，有磁表面存储器，光存储器和闪速存储器。</p>\n<ol>\n<li><p>数的表示形式：位、字节、字、双字、K、M、G、T、P、E、Z、Y、B、N、D；</p>\n</li>\n<li><p>位，即比特（bit），通常用<strong>b</strong>表示，是计算机中最小的信息单位，是用0或1来表示的一个二进制数位；</p>\n</li>\n<li><p>字节（Byte），8位二进制数表示一个字节，通常用<strong>B</strong>表示，是最基本的数据单位；</p>\n</li>\n<li><p>计算机中各种信息都普遍采用二进制数的形式来传送，存储和加工；</p>\n</li>\n<li><p>数制：十进制数（D） 、二进制数（B） 、八进制数（Q） 和十六进制数（H） ；</p>\n</li>\n<li><p>在程序设计中，为了区分不同进制的数，通常在数字后用一个英文字母作后缀以示区别；</p>\n</li>\n<li><p>逻辑运算：逻辑乘，逻辑加（或），逻辑非，逻辑异或；</p>\n</li>\n</ol>\n<p>（1）与运算（逻辑乘）：条件同真时，结果才为真；当条件中任意一个为假，结果必定为假；通常用X，^，∩或AND等来表示“与”；</p>\n<p>（2）或运算（逻辑加）：条件中任意一个为真时，结果就为真；当两个条件都为假时，结果才为假；通常用+，∨，∪或OR等表示“或”；</p>\n<p>（3）非运算：否运算，求反运算；通常在逻辑变量上加一横线，也可以用“<strong>¬</strong>”表示；</p>\n<p>（4）异或逻辑：对两个数进行异或操作就是按位求它们的模2和，故异或逻辑又有“按位加”之称；通常用“⊕”表示；两个条件值相同时，结果为0；两个条件值不同时，结果为1；</p>\n<ol>\n<li><p>无符号数:整个机器字长的全部二进制位均表示数值位，即没有符号位，相当于数的绝对值；机器字长为n位的无符号数表示的范围是0~（2^n-1）;</p>\n</li>\n<li><p>带符号数：通常约定二进制数的最高位为符号位，“<strong>0</strong>”表示正号，“<strong>1</strong>”表示负号；</p>\n</li>\n<li><p>机器数：在机器中，把一个数连同其符号在内数值化表示的数称作机器数；一般用最高有效位表示数的符号；</p>\n</li>\n<li><p>原码：原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值；</p>\n</li>\n<li><p>反码：正数的反码是其本身，负数的反码是在其<u>原码的基础上</u>，<strong>符号位</strong>不变，其余各个位取反；</p>\n</li>\n<li><p>补码：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1(也即在反码的基础上+1)；</p>\n</li>\n<li><p>一条机器指令必须由两部分组成：操作码和地址码；</p>\n</li>\n</ol>\n"},{"title":"汇编语言note.3","url":"/2023/04/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note.3/","content":"<h1 id=\"80x86指令系统\"><a href=\"#80x86指令系统\" class=\"headerlink\" title=\"80x86指令系统\"></a>80x86指令系统</h1><h4 id=\"1-加法指令：\"><a href=\"#1-加法指令：\" class=\"headerlink\" title=\"1.加法指令：\"></a>1.加法指令：</h4><p><strong>add</strong>：不带进位加法指令</p>\n<p>格式：add opd，ops </p>\n<p>完成两个操作数的相加，并将其放在opd中，其中opd可以是寄存器和内存单元，ops为寄存器，内存单元或立即数；</p>\n<p>对标志位CF和OF有影响，CF=1表示最高有效位向更高位有进位，为0则表示无进位；OF=1表示两个同符号数相加结果符号与其相反，即相加结果溢出，为0表示两个不同符号数相加，或同符号数相加，结果符号与其相同；</p>\n<p>剩下的标识符被结果所影响，</p>\n<p>对SF的影响：反映有符号数运算结果的正负性，正数为0，负数为1；</p>\n<p>对ZF的影响：判断结果是否为0，结果为0，ZF=1，否则ZF=0；</p>\n<p>对PF的影响：结果的二进制表示中1的个数是否为偶数，若1的个数为偶数，PF=1；若1的个数为奇数，PF=0；</p>\n<p>对AF的影响：在进行算术运算的时候，如果低字节中低4位产生进位或者借位的时候，则置1，否则置0。即当两个字节相加时，如果从第3位向第4位形成了进位，则AF=1</p>\n<p><strong>adc</strong>：带进位加法指令</p>\n<p>格式：adc opd，ops</p>\n<p>在add的基础上，相加时加上CF，即opd&lt;-opd+ops+cf，其中opd与ops要求与add相同；</p>\n<p>对标志位的影响和add相同；</p>\n<p><strong>inc指令</strong>：</p>\n<p>格式：inc opd</p>\n<p>opd的内容加1，其中opd可以是寄存器或内存单元，若是内存单元，应指定是字节或字单元；</p>\n<p>对标志位的影响除了不影响CF以外，和上面相同；</p>\n<h4 id=\"2-减法指令\"><a href=\"#2-减法指令\" class=\"headerlink\" title=\"2.减法指令\"></a>2.减法指令</h4><p><strong>sub</strong>：不带借位减法</p>\n<p>格式：sub opd，ops</p>\n<p>完成两个操作数的相减，将其结果存放于opd，其中opd可以是寄存器和内存单元，ops为寄存器，内存单元或立即数；</p>\n<p>对CF的影响：CF=1表示减法运算中最高有效位向更高位有借位，即被减数小于减数，不够减的情况，CF=0则表示无借位；</p>\n<p>对OF的影响：OF=1 两数符号相反（正数-负数（相当与加上正数）=负数，或负数-正数=正数），而结果符号与减数相同，即溢出；OF=0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。</p>\n<p>对ZF,PF,SF,AF的影响和加法指令相同，都是结果影响标识符，影响条件一样，其中的AF为半借位；</p>\n<p><strong>sbb</strong>：带借位减法：</p>\n<p>格式：sbb opd，ops</p>\n<p>在sub的基础上再减去CF，结果存于opd，其中opd与ops要求与add相同；</p>\n<p>对标识符的影响如上；</p>\n<p><strong>dec</strong>指令：</p>\n<p>格式：dec opd</p>\n<p>相当于opd减去1，其中opd的含义与inc指令相同</p>\n<p><strong>neg</strong>：求补指令</p>\n<p>格式：neg opd</p>\n<p>对操作数opd进行求补运算，即对opd连同其符号位求反后加1，并将结果送回opd；</p>\n<p><strong>在计算机中，数据都是以补码的形式存储的</strong>，所以对操作数进行求补时，对于负数相当于求绝对值，对于正数相当于求正数相反数的补码表示；</p>\n<p>其中的opd可以是寄存器或者内存单元；</p>\n<p>对标识符的影响与用0减去opd的sub指令相同；</p>\n<p>其中对0求补时，CF=1，其他情况CF=1；</p>\n<p><strong>cmp</strong>：比较指令</p>\n<p>格式：cmp opd，ops</p>\n<p>执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数，该指令用于改变标志位(<u>当实际的减法发生时，CMP指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位</u>);</p>\n<p>无符号数比较：</p>\n<p>目的操作数&lt;源操作数 CF=1</p>\n<p>目的操作数&gt;源操作数 CF=0</p>\n<p>目的操作数=源操作数 ZF=1</p>\n<p>有符号数比较：</p>\n<p>目的操作数&lt;源操作数 SF≠OF</p>\n<p>目的操作数&gt;源操作数 SF=OF</p>\n<p>目的操作数=源操作数 ZF=1</p>\n<h4 id=\"3-乘法指令\"><a href=\"#3-乘法指令\" class=\"headerlink\" title=\"3.乘法指令\"></a>3.乘法指令</h4><p><strong>mul</strong>：无符号乘法数指令</p>\n<p>格式：mul opd</p>\n<p>操作数可以是寄存器和内存单元，但不能是立即数；当操作数为内存单元时应指明是字节还是字数据；</p>\n<p><strong>word ptr指明了指令访问的内存单元是一个字单元</strong>；</p>\n<p><strong>byte ptr指明了指令访问的内存单元是一个字节单元</strong>；</p>\n<p>实现两个无符号数的相乘，当opd为8为字节数据时为字节相乘，将AL与opd相乘，其中AL为隐含操作数（必须是AL），结果存于AX寄存器，AH存放高位字节，AL存放低位字节；当opd为16位字数据时为字相乘，将AX与opd相乘（必须是AX），将结果高位存于DX，低位存于AX；</p>\n<p>MUL指令对标志位CF、OF有影响，对SF、ZF、AF、PF 无定义;</p>\n<p>注：对标志位的“无定义”和“不影响”不同。无定义是指指令执行后，标志位的状态不确定；不影响是指指令的结果不影响标志位。即标志位保持原状态不变。</p>\n<p>如果运算结果的高一半（AH,DX）为零，则CF=OF=0，否则CF=OF=1；</p>\n<p><strong>imul</strong>：有符号乘法数指令</p>\n<p>格式：imul opd</p>\n<p>与mul相同，只是专用与有符号数的相乘，即要求两个操作数都须为有符号数；</p>\n<p>若乘积的高半部分是低半部分的符号位扩展，则OF=CF=0;否则OF=CF=1；</p>\n<p>注：</p>\n<h6 id=\"符号扩展\"><a href=\"#符号扩展\" class=\"headerlink\" title=\"符号扩展\"></a>符号扩展</h6><p>微机系统中，有时需要将一个数据从位数较少扩展到位数较多，例如，在执行除法指令时，由于对字节除数相除要求被除数为16位，对字除数要求被除数为32位，即被除数必须为除数的倍长数据，因此就涉及数据的位数扩展问题，具体的扩展有符号扩展与零扩展两种方法。</p>\n<p>当要扩展的数据是无符号数时可采用零扩展。即在最高位前扩展0，补充够位数即可。<br>当要扩展的数据是有符号数时需采用符号扩展。由于采用<strong>补码</strong>形式表示的整数具有固定的长度，因此在汇编指令系统中，经常有一些指令需要将其中的操作数进行符号位扩展。譬如两个8位或16位数据进行相加或者相减运算时，当有不足位数要求的数据时，需要将少位数据扩展成与位数要求相一致的数据；两个数据相除时，被除数应必须是除数的倍数等。<br>符号扩展的方法是将需要扩展的数据的符号位填入到扩展的每一位，以保持其作为有符号数的值的大小不变。这里要注意，<strong>要扩展的数须是用补码形式表示的有符号数</strong>，符号扩展后。其结果仍是该数的补码。<br>因此，对于补码表示的数，其正数的符号扩展是将其符号位0向左扩展（补0）；其负数的符号扩展是将其符号位1向左扩展（补1）。</p>\n<h6 id=\"符号扩展语句\"><a href=\"#符号扩展语句\" class=\"headerlink\" title=\"符号扩展语句\"></a>符号扩展语句</h6><p>字节扩展为字指令CBW<br>指令格式：CBW<br>功能：该指令的隐含操作数为AH和AL，功能是用AL的符号位去填充AH，即若AL为正数，则AH=00H；否则AH=FFH。<br>字扩展为双字指令CWD<br>指令格式：CWD<br>功能：该指令的隐含操作数为DX和AX，功能是用AX的符号位填充DX，即若AX为正数，则DX=0000H；否则DX=FFFFH。<br>以上两条指令的执行都不影响任何标志位。</p>\n<p>有符号相乘的步骤：</p>\n<ol>\n<li>符号位扩展（负数前面补1，正数补0）</li>\n<li>扩展后的数据两式相乘</li>\n<li>求补（计算机中存放的是补码）</li>\n<li>取有效位，比如3位数据相乘，得到的结果取有效位6位即可。</li>\n</ol>\n<h4 id=\"4-除法指令\"><a href=\"#4-除法指令\" class=\"headerlink\" title=\"4.除法指令\"></a>4.除法指令</h4><p><strong>div</strong>：无符号除法</p>\n<p>格式：div opd</p>\n<p>操作数可以是寄存器或内存单元，不能是立即数；</p>\n<p>实现两个无符号数的除法运算，当opd为8位字节数据时为字节相除，被除数在AX中，除数在opd中，al存放商，ah存放余数，其中AX是隐含操作数；当opd为16位字数据时为字相除，被除数在DX和AX中，DX存放高字节，AX存放低字节，AX存放商，DX存放余数，AX，DX是隐含操作数；</p>\n<p>除法指令对所有标志位均无定义，但会产生<strong>除法溢出</strong>。</p>\n<p>如果被除数高位的数值等于或大于除数，那么会产生溢出，也就是说除法的商放不下容纳它的位置，就会产生除法溢出，这将导致处理器异常并暂停执行当前程序，</p>\n<p><strong>idiv</strong>：有符号数除法指令</p>\n<p>格式与功能和div类似，只是专用于有符号数的相除；</p>\n"},{"title":"汇编语言note.2","url":"/2023/03/26/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note.2/","content":"<h2 id=\"1-微处理器\"><a href=\"#1-微处理器\" class=\"headerlink\" title=\"1.微处理器\"></a>1.微处理器</h2><p>8086微处理器由执行指令单元EU和总线接口单元BIU组成：</p>\n<p>EU部分负责指令的执行，由ALU，标志寄存器，通用寄存器，数据寄存器和EU控制单元组成；EU主要实现两种操作，一种是根据指令进行算术/逻辑运算；二是由EU计算出指令要求的寻址单元的偏移地址量；</p>\n<p>BIU负责与存储器接口，即808CPU与存储器之间的信息传送，8086由地址加法器，段寄存器，指令指针IP，指令队列和总线控制逻辑组成；BIU完成从内存的指令单元去除指令，送至指令流队列中排队，执行指令时所需的操作数也有BIU从指定区域取出，送至EU中区执行；</p>\n<p>EU和BIU的操作是独立进行的；</p>\n<p><img src=\"C:\\Blog\\blog\\source\\_posts\\汇编语言note.2\\图片1.png\" alt=\"\"></p>\n<p>地址加法器：将指令指针IP和段寄存器CS或者EU送来的地址偏移量与段寄存器DS形成的一个20为的物理地址；（就物理地址的形成方法：物理地址=段地址*16+偏移地址）</p>\n<h2 id=\"2-寄存器\"><a href=\"#2-寄存器\" class=\"headerlink\" title=\"2.寄存器\"></a>2.寄存器</h2><p>80x86共14个16位寄存器，分别为<strong>数据寄存器，指针及变址寄存器，段寄存器和控制寄存器</strong>；所有寄存器都是16位的，可以存放两个字节；</p>\n<p><strong>数据寄存器</strong>：AX,BX,CX,DX；用来暂时存放运算过程中的初中生，结果数据或其他数据；</p>\n<p>为了保证兼容性，这4个寄存器又可以分为两个可以<strong>独立使用</strong>的8位寄存器，</p>\n<p>·AX分为AH和AL</p>\n<p>·BX分为BH和BL</p>\n<p>·CX分为CH和CL</p>\n<p>·DX分为DH和DL</p>\n<p>AH,BH,CH,DH为高8位寄存器，AL,BL,CL,DL位低8位寄存器；除了上面 4 个数据寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器 ；</p>\n<p>这四个都是通用寄存器，但又可以用于专用目的；</p>\n<p>AX：累加器，其特殊用途是在使用 DIV （除法指令）和 MUL （乘法指令）时使用：</p>\n<p>DIV 在 8086 CPU 中是除法指令，而在使用除法的时候有两种情况，即除数可以是 8 位或者是 16 位的，而且除数可以存放在寄存器中或者是内存单元中，而至于被除数的话，自然，应该由 AX 来代替了；</p>\n<p>当除数是 8 位时，被除数一定会是 16 位的，并且默认是放在 AX 寄存器中，</p>\n<p>而当除数是 16 位时，被除数一定是 32 位的，因为 AX 是 16 位寄存器，自然，放不下 32 位的被除数，</p>\n<p>所以，在这里还需要使用另一个 16 位寄存器 DX ，其中 DX 存放 32 位的被除数的高 16 位，而 AX 则存放 32 位的被除数的低 16 位；</p>\n<p>同时，AX 的作用还不仅仅是用来保存被除数的，当除法指令执行完成以后，如果除数是 8 位的，则在 AL 中会保存此次除法操作的商，而在 AH 中则会保存此次除法操作的余数，当然，如果除数是 16 位的话，则 AX 中会保存本次除法操作的商，而 DX 则保存本次除法操作的余数。（<u>低位保存商，高位保存余数</u>）</p>\n<p>当使用     MUL 做乘法运算时，两个相乘的数要么都是 8 位，要么都是 16 位，</p>\n<p>如果两个相乘的数都是 8 位的话，则一个默认是放在 AL 中，而另一个 8 位的乘数则位于其他的寄存器或者说是内存字节单元中，</p>\n<p>而如果两个相乘的数都是 16 位的话，则一个默认存放在 AX 中，另一个 16 位的则是位于 16 位的寄存器中或者是某个内存字单元中；</p>\n<p>同时，当 MUL 指令执行完毕后，如果是 8 位的乘法运算，则默认乘法运算的结果是保存在 AX 中，而如果是 16 位的乘法运算的话，则默认乘法运算的结果有 32 位，其中，高位默认保存在 DX 中，而低位则默认保存在 AX 中。</p>\n<p>BX：其中数据一般可以用来作为偏移地址使用；</p>\n<p>CX：有计数器的功能;</p>\n<p>当在汇编指令中使用循环 LOOP 指令时，可以通过 CX 来指定需要循环的次数，而 CPU 在每一次执行 LOOP 指令的时候，都会做两件事：一件就是令 CX = CX – 1，即令 CX 计数器自动减去 ，还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，当然如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令 。</p>\n<p>在位操作中，当位移多位时，用CL来指明移位的位数；</p>\n<p>DX:部分用法同AX；在间接寻址的I/O指令中提供端口地址；</p>\n<p><strong>指针及变址寄存器</strong>：包括SP,BP,SI,DI；可以与数据寄存器一样在运算过程中存放操作数，但只能以16位使用，另外其常用于在段内寻址时提供偏移地址；</p>\n<p>SP：堆栈(即栈)指针寄存器；SP用来指出当前堆栈的栈顶的位置，在堆栈指令操作时，由它给出入栈或出栈的数据在栈中的偏移地址，与SS堆栈段寄存器一起形成栈顶存储单元的物理地址；</p>\n<p>BP：基址指针寄存器；用来指示堆栈中某个数据区的偏移地址，与SS堆栈段寄存器一起形成堆栈中<strong>某个</strong>存储单元的物理地址；可以对堆栈中任意位置的数据进行操作，但不具备SP始终指向栈顶的含义；</p>\n<p>当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，那么如果在指令中没有明确或者说是显示的给出段地址时，段地址则使用默认的 SS 寄存器中的值（BX，SI，DI 会默认使用 DS 段寄存器），比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，</p>\n<p>所以，这里代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元，</p>\n<p>而如果单单是使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。</p>\n<p>SI(源变址寄存器)与DI(目的变址寄存器)：这两个寄存器与DS数据段寄存器一起用来确定<strong>数据段</strong>中某一存储单元的物理地址；拥有自动增量和自动减量的功能；</p>\n<p><strong>段寄存器</strong>：CS,SS,DS,ES，四个16位的段寄存器；</p>\n<p>CS：代码段寄存器，和IP一起用，组成一组寄存器：CS:IP；</p>\n<p>CS指示基地址（也就是段地址左移 4 位），IP指示偏移地址；</p>\n<p>这组寄存器指示了当前CPU要读取的指令的地址；任何时候，CS:IP 指向的地址中的内容都是 CPU 当前执行的指令；</p>\n<p>SS：堆栈段寄存器，和SP一起用；在任何时刻，SS:SP 都是指向栈顶元素 。</p>\n<p>SS指示基地址（也就是段地址左移 4 位），SP指示偏移地址；</p>\n<p>DS：数据段寄存器；DS 中存放的是数据段的段地址；</p>\n<p>ES：附加段寄存器；相当于其他段寄存器的扩展，当其他段寄存器不够用时，可以考虑使用ES寄存器；</p>\n<p><strong>控制寄存器</strong>：IP,PSW；</p>\n<p>IP：指针指令寄存器，用来存放代码段宏的偏移地址，和CS一起联用；</p>\n<p>PSW：程序状态字寄存器，或者称为标志寄存器（FLAGS）；</p>\n<p>在 PSW 中，数据是按位起作用的，也就是说，PSW 中的每一个位都表示不同的状态，由于一个位也就能表示 0 和 1 ，自然，PSW中的每一个位就是用来描述状态的，</p>\n<p>不同的位分别表示不同状态和意义：</p>\n<p>CF（第0位）：进位标志，是用来反映计算时是否产生了由低位向高位的进位，或者产生了从高位到低位的借位 ，注意进位与溢出时含义不同的标志，有进位时CF=1，否则置零；</p>\n<p>PF（第2位）：奇偶标志，用来为机器中传送信息时肯产生的代码错误情况提供检验条件，当结果操作数中1的个数为偶数时PF置1，否则置0；常用于逻辑运算中；</p>\n<p>AF（第4位）：辅助进位标志，记录运算时第3位（从0开始算位）产生的进位值或借位值，有进位或借位时AF位置1，否则置0；</p>\n<p>ZF（第6位）：零标志，运算执行结果位0时ZF位置1，否则置0；常用于分支程序或者循环程序的转移控制；</p>\n<p>SF（第7位）：符号标志，记录运算结果的符号，为负时SF位置1，否则置0；常用于表示有符号数运算结果的正负；</p>\n<p>TF（第8位）：陷阱标志，或单步跟踪标志，用于调试时的单步方式操作；当 TF 置 0 时，处理器在正常模式下运行；当 TF置 1 时，处理器单步执行指令，调试器可以逐条指令进行执行就是使用了该标志位。</p>\n<p>IF（第9位）：中断标志，当IF位为1时，CPU 能够响应外部的可屏蔽中断请求;否则关闭请求，本标志对外部中断进行管理；</p>\n<p>DF（第10位）：方向标志，其用于在串处理指令中，用来控制处理信息的方向，当DF位为1时，每次操作后使变址寄存器SI和DI减少，这样就能使串处理从高地址向低地址方向处理，当DF位为0时，每次操作后使SI和DI增大，串处理就能从低地址向高地址方向处理；</p>\n<p>OF（第11位）：溢出标志，其通常记录了有符号数运算的结果是否发生了溢出 ，如操作数是否超出机器能表示的数据范围；溢出时OF为1，否则为0，溢出时表面运算结果错误，一般通过溢出中断处理加以解决；</p>\n"},{"title":"汇编语言note.5","url":"/2023/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note.5/","content":"<h2 id=\"逻辑运算指令\"><a href=\"#逻辑运算指令\" class=\"headerlink\" title=\"逻辑运算指令\"></a>逻辑运算指令</h2><p>逻辑运算指令用于实现逻辑运算功能，有单操作数和双操作数之分，操作数可以为8位或者16位二进制数，但双操作数不允许两个操作数都是存储器操作数，目的操作数不能是立即数，两个操作数的位数要一致；</p>\n<h4 id=\"AND：逻辑与运算指令\"><a href=\"#AND：逻辑与运算指令\" class=\"headerlink\" title=\"AND：逻辑与运算指令\"></a>AND：逻辑与运算指令</h4><p>与：当两者都为1时结果取1，否则都取0；</p>\n<p>格式：AND OPD,OPS</p>\n<p>对两个操作数执行按位的逻辑与运算，结果送到目的操作数；</p>\n<p>功能：可屏蔽某些位(将这些位置0) 注：和0与清零，和1与保留原来的值；</p>\n<p>设置CF=OF=0；根据结果确定SF,ZF和PF，对AF则无定义；</p>\n<h4 id=\"OR：逻辑或运算指令\"><a href=\"#OR：逻辑或运算指令\" class=\"headerlink\" title=\"OR：逻辑或运算指令\"></a>OR：逻辑或运算指令</h4><p>或：当两者中均没有0时，取1；只有两者都为0时，取0；</p>\n<p>格式：OR OPD,OPS</p>\n<p>对两个操作数执行按位逻辑或运算，结果送到目的操作数；</p>\n<p>功能: 使某些位置为1；</p>\n<p>对标志位的影响同AND指令；</p>\n<h4 id=\"NOT：逻辑非指令\"><a href=\"#NOT：逻辑非指令\" class=\"headerlink\" title=\"NOT：逻辑非指令\"></a>NOT：逻辑非指令</h4><p>非：按位取反，原来是“0”的位变为“1”，原来是“1”的位变为“0”;</p>\n<p>格式：NOT OPD</p>\n<p>对标志位没有影响；</p>\n<h4 id=\"XOR：逻辑异或运算\"><a href=\"#XOR：逻辑异或运算\" class=\"headerlink\" title=\"XOR：逻辑异或运算\"></a>XOR：逻辑异或运算</h4><p>异或：两者相同时候，输出0；两者不同时，输出1；</p>\n<p>格式：XOR OPD,OPS</p>\n<p>对两个操作数执行按位逻辑异或运算，结果送到目的操作数；</p>\n<p>功能：使操作数的某些位取反或测试两数是否相等；</p>\n<p>对标识位的影响同AND指令一样；</p>\n<h4 id=\"TEST：测试指令\"><a href=\"#TEST：测试指令\" class=\"headerlink\" title=\"TEST：测试指令\"></a>TEST：测试指令</h4><p>格式：TEST OPD,OPS</p>\n<p>对两个操作数执行逻辑与运算，但结果不送回目的操作数，仅建立结果状态标志；</p>\n<p>可以用来检测一些条件是否满足，但不会改变原操作数的内容；</p>\n<p>对标识符的影响：SF：将结果的最高位赋给SF标志位，例如结果最高位是1，SF就是1；</p>\n<p>ZF：看TEMP是不是0，如果TEMP是0，ZF位置1；如果TEMP不是0，ZF位置0；</p>\n<p>PF：PF位是奇偶校验位，如果结果低8位中1的个数是偶数，PF=1；否则PF=0;</p>\n<p>CF=OF=0；</p>\n<h2 id=\"移位指令\"><a href=\"#移位指令\" class=\"headerlink\" title=\"移位指令\"></a>移位指令</h2><p>移位指令都有两个操作数，OPD是指定的被移位的操作数，可以是寄存器或者存储单元，OPS表示移位位数，该操作数为1时，表示移动1位，当移位位数大于1时，则OPS为CL寄存器值（即当数值大于1时，数要先传入CL寄存器）；</p>\n<p>有符号数使用算术移位，无符号数使用逻辑移位；</p>\n<h4 id=\"SAL-SHL-算术-逻辑左移\"><a href=\"#SAL-SHL-算术-逻辑左移\" class=\"headerlink\" title=\"SAL/SHL:算术/逻辑左移\"></a>SAL/SHL:算术/逻辑左移</h4><p>格式：  SAL/SHL OPD,OPS</p>\n<p>将操作数左移，最低位补0，最高位进CF；</p>\n<h4 id=\"SAR：算术右移\"><a href=\"#SAR：算术右移\" class=\"headerlink\" title=\"SAR：算术右移\"></a>SAR：算术右移</h4><p>格式：SAR OPD,OPS；</p>\n<p>操作数右移，最高位不变（即最高位原来是1/0，右移过后最高位就补1/0），最低位进CF；</p>\n<h4 id=\"SHR：逻辑右移\"><a href=\"#SHR：逻辑右移\" class=\"headerlink\" title=\"SHR：逻辑右移\"></a>SHR：逻辑右移</h4><p>格式：SHR OPD,OPS</p>\n<p>操作数右移，最高位补0，最低位进CF；</p>\n<p><em>逻辑左移一位相当于无符号数乘以2，右移一位相当于无符号数除以2</em></p>\n<p><em>算术左移一位相当于有符号数乘以2，右移一位相当于有符号数除以2</em></p>\n<p>移位指令对AF无定义，CF为移位后确定的值，并根据移位后的结果设置SF,ZF,PF；当移位后符号发生变化，则OF=1，否则OF=0；当移位次数大于1时，OF不确定；</p>\n<h2 id=\"循环移位指令\"><a href=\"#循环移位指令\" class=\"headerlink\" title=\"循环移位指令\"></a>循环移位指令</h2><p><strong>ROL</strong>：不带进位循环左移</p>\n<p>格式：ROL OPD,OPS；</p>\n<p>指令把所有位都向左移。最高位复制到标志位CF和最低位,位循环不会丢弃位。从数的一端循环出去的位会出现在该数的另一端;</p>\n<p><strong>ROR</strong>：不带进位循环右移</p>\n<p>格式：ROR OPD,OPS；</p>\n<p>指令把所有位都向右移，最低位复制到标志位CF和最高位;</p>\n<p><strong>RCL</strong>：带进位循环左移</p>\n<p>格式：RCL OPD,OPS；</p>\n<p>指令把每一位都向左移，标志位CF复制到最低有效位，而最高有效位复制到标志位CF：</p>\n<p><strong>RCR</strong>：带进位循环右移</p>\n<p>格式：RCR OPD,OPS；</p>\n<p>指令把每一位都向右移，标志位CF复制到最高有效位，而最低有效位复制到标志位CF;</p>\n"},{"title":"汇编语言note4","url":"/2023/04/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note.4/","content":"<h3 id=\"十进制数调整指令\"><a href=\"#十进制数调整指令\" class=\"headerlink\" title=\"十进制数调整指令\"></a>十进制数调整指令</h3><h4 id=\"BCD码\"><a href=\"#BCD码\" class=\"headerlink\" title=\"BCD码\"></a>BCD码</h4><p>组合BCD码：即压缩BCD码，用4个二进制位表示一个十进制位，就是一个字节含两位BCD码；</p>\n<p>分离BCD码：即非压缩BCD码，用8个二进制位表示一个十进制位，就是指一个字节含一位BCD码，字节的高四位无意义，通常默认为0；</p>\n<p>BCD码的加减乘除调整指令的对象均为隐含寄存器AL，其运算只能使用以AL寄存器为目的操作数的8位数运算指令；</p>\n<p><strong>压缩BCD码的调制指令</strong></p>\n<p>该指令不影响OF（无定义）,但对其他五个标志位产生影响；</p>\n<p>对存于AL中的结果进行调整，产生一个压缩组合的十进制数在AL中；</p>\n<p><strong>DAA</strong>:加法调整指令</p>\n<p>调整方法：加法运算后，低4位若向高4位有进位（即AF=1）或低４位&gt;９时，调整指令应做加06H处理；高４位&gt;９或当CF=１（有进位产生）时时，调整指令需做加60H处理；</p>\n<p><strong>DAS</strong>：减法调制指令</p>\n<p>调整方法: 减法运算后，低4位若向高4位有借位（即AF=1）或低４位&gt;９时，调整指令应做减06H处理；高４位&gt;９或当CF=１（有借位产生）时，调整指令需做减60H处理；</p>\n<p><strong>非压缩BCD码的调制指令</strong></p>\n<p>指令影响AF和CF标志，但对标识符SF、ZF、PF和OF的状态不确定；</p>\n<p>未压缩型BCD码即为用一个字节表示0~9 ,高四位为 0000 ，低四位表示 0~9；</p>\n<p>存于AL中的结果进行调整，产生一个压缩组合的十进制数在AX中；</p>\n<p><strong>AAA</strong>：加法调整指令</p>\n<p>调整方法：当AL中的低四位&lt;A且AF=0时，则清除AL高四位；当低四位在A~F之间或AF=1时，AL加06H，AH加1，将AF置1，把AF位值送CF位，再清除AL高四位；</p>\n<p><strong>AAS</strong>：减法调整指令</p>\n<p>调整方法：当AL低四位&gt;9或AF=1时，AL-06H，AH-01H,将AF置1，把AF位值送CF位，再清除AL高四位;当AL中的低四位&lt;A且AF=0时，则清除AL高四位;</p>\n<p><em>对于十进制数的乘除法运算，8086／8088指令系统只提供了非压缩型BCD码的调整指令，而没有提供压缩型BCD码的调整指令；</em></p>\n<p><em>非压缩型BCD码的乘除法与加减法不同，加减法可以直接用ASCII码参加运算，而不管其高位上有无数字，只要在加减指令后用一条非压缩型BCD码的调整指令就能得到正确结果。而乘除法要求参加运算的<strong>两个数必须是高４位为０的非压缩型BCD码</strong>，低４位为一个十进制数。也就是说，如果用ASCII码进行非压缩型BCD码乘除法运算的话，在乘除法运算之前，必须将高４位清零。</em></p>\n<p><strong>AAM</strong>:乘法调整指令</p>\n<p>对存于AX中的结果进行调整，产生一个未压缩的十进制数存在于AX中，即AH存放AL/10的商，AL存放AL%10的余数；</p>\n<p>对CF,OF,AF无定义，影响PF,SF,ZF；</p>\n<p><strong>AAD</strong>：除法调整指令</p>\n<p>调整方法：把AX中的两个未压缩十进制数进行调整，然后按DIV指令实现两个未压缩十进制数的除法运算，AL存放未压缩十进制商，AH存放余数，即AL放AH*10+AL，AH为0；</p>\n<p>根据AL中的结果影响状态标志位SF、ZF和PF，但其余几个状态标志位如AF、CF和OF的值则不确定；</p>\n<p>AAD指令的用法与其它非压缩型BCD码调整指令（如AAA、AAS、AAM）有所不同。AAD指令不是在除法之后，而是在除法之前进行调整，然后用DIV指令进行除法，所得之商还需用AAM指令进行调整，方可得到正确的非压缩型BCD码的结果；</p>\n"},{"title":"汇编语言note.6","url":"/2023/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note.6/","content":"<h2 id=\"控制转移指令\"><a href=\"#控制转移指令\" class=\"headerlink\" title=\"控制转移指令\"></a>控制转移指令</h2><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令；</p>\n<p><strong>JMP</strong>：无条件转移指令</p>\n<p>格式：JMP LABLE</p>\n<p>使程序无条件转到指定的地址，从指定地址处开始执行指令，因此无条件转移指令必须指明所要转移的地址；</p>\n<p>根据所要转移的地址是否与当前指令在一个代码段，无条件转移可分为段内转移和段间转移；又根据所要转移的地址的不同寻址方式，又可分为直接寻址和间接寻址；</p>\n<p>段内转移是在同一代码段内进行，又称近转移(NEAR PTR)，只要修改IP的值即可实现,转移范围在-128~+127称为短转移(SHORT)；段间转移可以在不同代码之间进行，又称远转移(FAR PTR)，需要同时修改CS和IP的值;</p>\n<p>在实际编程中，汇编程序会根据目标地址的距离自动处理短或远转移，程序员可以用操作符SHORT,NEAR PTR或FAR PTR强制控制；</p>\n<p>直接转移是指转移的目标地址直接出现在指令中，在程序执行前就已经确定；间接转移是指转移的目标地址是寄存器或内存操作数的值，只有执行到该条指令时才能确定;</p>\n<p>(1)段间直接转移：jmp 段地址：偏移地址</p>\n<p>(2)段内间接转移：jmp 某一合法寄存器（用寄存器的值修改IP的值）</p>\n<p>注意：如果jmp内存操作数是字类型，则masm自动产生段内间接转移(单字变量取代IP值)；若内存操作数是双字类型，则masm自动产生段间间接转移(用一个双字内存变量中的低16位取代IP值，高16位取代CS值)。当不能确定类型时，masm将报错。</p>\n<p><strong>JCC</strong>：条件转移指令</p>\n<p>条件转移语句都是段内短转移；</p>\n<p>格式：JCC LABLE</p>\n<p>条件满足，则发生转移IP=LABLE；否则不转移，顺序执行下面的语句；</p>\n<p>指令中的条件即为状态标志的状态，使用这些条件转移指令可分成三类：判断单个标志位状态，比较无符号数高低，比较有符号数大小；</p>\n<p><strong>(1)单个标志位状态</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>JCC指令</th>\n<th style=\"text-align:center\">中文含义</th>\n<th style=\"text-align:center\">检查符号位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JZ/JE</td>\n<td style=\"text-align:center\">若为0则跳转；若相等则跳转</td>\n<td style=\"text-align:center\">ZF=1</td>\n</tr>\n<tr>\n<td>JNZ/JNE</td>\n<td style=\"text-align:center\">若不为0则跳转；若不相等则跳转</td>\n<td style=\"text-align:center\">ZF=0</td>\n</tr>\n<tr>\n<td>JS</td>\n<td style=\"text-align:center\">若为负则跳转</td>\n<td style=\"text-align:center\">SF=1</td>\n</tr>\n<tr>\n<td>JNS</td>\n<td style=\"text-align:center\">若为正则跳转</td>\n<td style=\"text-align:center\">SF=0</td>\n</tr>\n<tr>\n<td>JP/JPE</td>\n<td style=\"text-align:center\">若1出现次数为偶数则跳转</td>\n<td style=\"text-align:center\">PF=1</td>\n</tr>\n<tr>\n<td>JNP/JPO</td>\n<td style=\"text-align:center\">若1出现次数为奇数则跳转</td>\n<td style=\"text-align:center\">PF=0</td>\n</tr>\n<tr>\n<td>JO</td>\n<td style=\"text-align:center\">若溢出则跳转</td>\n<td style=\"text-align:center\">OF=1</td>\n</tr>\n<tr>\n<td>JNO</td>\n<td style=\"text-align:center\">若无溢出则跳转</td>\n<td style=\"text-align:center\">OF=0</td>\n</tr>\n<tr>\n<td>JC/JB/JNAE</td>\n<td style=\"text-align:center\">若进位则跳转；若低于则跳转；若不高于等于则跳转</td>\n<td style=\"text-align:center\">CF=1</td>\n</tr>\n<tr>\n<td>JNC/JNB/JAE</td>\n<td style=\"text-align:center\">若无进位则跳转；若不低于则跳转；若高于等于则跳转</td>\n<td style=\"text-align:center\">CF=0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>(2)比较无符号数高低</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>JCC指令</th>\n<th style=\"text-align:center\">中文含义</th>\n<th style=\"text-align:center\">检查符号位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JC/JB/JNAE</td>\n<td style=\"text-align:center\">若进位则跳转；若低于则跳转；若不高于等于则跳转</td>\n<td style=\"text-align:center\">CF=1</td>\n</tr>\n<tr>\n<td>JNC/JNB/JAE</td>\n<td style=\"text-align:center\">若无进位则跳转；若不低于则跳转；若高于等于则跳转</td>\n<td style=\"text-align:center\">CF=0</td>\n</tr>\n<tr>\n<td>JBE/JNA</td>\n<td style=\"text-align:center\">若低于等于则跳转；若不高于则跳转</td>\n<td style=\"text-align:center\">ZF=1或CF=1</td>\n</tr>\n<tr>\n<td>JNBE/JA</td>\n<td style=\"text-align:center\">若不低于等于则跳转；若高于则跳转</td>\n<td style=\"text-align:center\">ZF=0且CF=0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>(3)比较有符号数大小</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>JCC指令</th>\n<th style=\"text-align:center\">中文含义</th>\n<th style=\"text-align:center\">检查符号位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JL/JNGE</td>\n<td style=\"text-align:center\">若小于则跳转；若不大于等于则跳转</td>\n<td style=\"text-align:center\">SF != OF</td>\n</tr>\n<tr>\n<td>JNL/JGE</td>\n<td style=\"text-align:center\">若不小于则跳转；若大于等于则跳转；</td>\n<td style=\"text-align:center\">SF = OF</td>\n</tr>\n<tr>\n<td>JLE/JNG</td>\n<td style=\"text-align:center\">若小于等于则跳转；若不大于则跳转</td>\n<td style=\"text-align:center\">ZF != OF 或 ZF=1</td>\n</tr>\n<tr>\n<td>JNLE/JG</td>\n<td style=\"text-align:center\">若不小于等于则跳转；若大于则跳转</td>\n<td style=\"text-align:center\">SF=0F 且 ZF=0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>测试CX的值为0，则转移的指令</strong></p>\n<p>格式：JCXZ LABLE</p>\n<p>如果CX寄存器的内容为0，则转移到指定的地址标号出；</p>\n<p><strong>循环控制指令</strong></p>\n<p>循环指令默认利用CX计数器，属于段内短转移；</p>\n<p>LOOP的功能是将CX=CX-1，然后判断CX≠0？来控制程序的执行顺序；</p>\n<p>格式： LOOP LABLE</p>\n<p>CX=CX-1，如果CX≠0，则转到LABLE，进行循环；否则推退出，顺序执行下一句；</p>\n<p>格式：LOOPZ/LOOPE LABLE</p>\n<p>CX=CX-1，如果CX≠0且ZF=1，则转到LABLE，循环；否则退出，顺序执行下一句；</p>\n<p>格式：LOOPNZ/LOOPNE LABLE</p>\n<p>CX=CX-1，如果CX≠0且ZF=0，转到LABLE进行循环；否则退出循环，顺序执行下一句；</p>\n<p><strong>子程序调用及返回指令</strong></p>\n<p>子程序是完成特定功能的一段程序，采用子程序能够提高编程的效率，使程序更加清楚，以便于维护；</p>\n<p><strong>CALL</strong>：子程序调用指令</p>\n<p>在执行CALL时将CALL的下一条指令的地址（段地址，偏移地址）压入堆栈中，以便子程序执行结束后正确返回；然后转移到目标地址；</p>\n<p>CALL指令位于主程序中，子程序可以和指令在同一代码段内，也可以在不同的代码段，所以分为<u>段内调用</u>和<u>段间调用</u>；调用时有<u>直接寻址</u>和<u>间接寻址</u>两种方式，故调用指令有四种格式；</p>\n<p>格式：CALL (NEAR PTR) LABLE</p>\n<p>段内直接调用，这个指令是先将call + 标号的下一条语句的IP放入栈中，然后使当前的IP+16位位移;</p>\n<p>格式：CALL 16位寄存器或内存单元操作数</p>\n<p>段内间接调用，这个指令先将call的下一条指令的IP入栈，然后再以操作数作为IP的修改后的值；</p>\n<p>格式：CALL FAR PTR LABLE</p>\n<p>段间直接调用，这个指令是先将call指令的下一个指令的代码段地址入栈，再把call下一条指令的偏移地址入栈，然后使其跳到标号所在处;</p>\n<p>格式：CALL FAR  内存单元操作数</p>\n<p>段间间接调用，高位为CS的值，低位为IP的值；</p>\n<p><strong>RET</strong>：返回指令，为子程序最后执行的指令，与CALL成对出现，将堆栈中CALL的下一条指令的段地址和偏移地址送回CS,IP；</p>\n<p>根据段内和段间，有无参数分成四类；</p>\n<p>格式：RET(N)</p>\n<p>用栈中的数据，修改IP的内容，从而实现<strong>近转移</strong>；</p>\n<p>格式：RETF</p>\n<p>用栈中的数据，修改CS和IP的内容，从而实现<strong>远转移</strong>；</p>\n<p>格式：RET N</p>\n<p>N作为一个16位立即数，则堆栈指针SP增加，SP=SP+N，方便程序从堆栈段中去除若干CALL指令之后的入栈参数；</p>\n<p>格式：RETF N</p>\n<p>最后，call、ret、retf 这三条指令执行后不会对标志位产生影响</p>\n"},{"title":"汇编语言note.7","url":"/2023/04/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note.7/","content":"<h3 id=\"处理器控制指令\"><a href=\"#处理器控制指令\" class=\"headerlink\" title=\"处理器控制指令\"></a>处理器控制指令</h3><p><strong>空操作指令：NOP</strong></p>\n<p>格式：NOP</p>\n<p>不执行任何操作，但占用一个字节存储单元，空耗一个指令执行周期，当指令间需要有延时（给外部设备足够的响应时间；或是软件的延时等），可以插入“NOP”指令；用于程序指令的对齐，Nop有1-9Byte9种写法, 以方便对齐指令；在预留指令空间或代码空间多余时可以用NOP进行填充；</p>\n<ul>\n<li>假设程序已经设计好了一个相对转移, 转移对象是100 bytes forward. 半年后, 程序员决定在99 bytes forward的地方删减1行代码, 但是这样做的话, 相对转移的对象地址不就变化了么? 为了避免这种问题, 只要不删减代码, 而是把想删减的代码改写成NOP就可以了.</li>\n<li>Nop sled. 这是一种代码滑行, 假设一个程序想要跳转, 但是只知道目标地址是250 bytes forward左右, 并不确定. 这个时候一个好办法就是跳转到200 bytes forward, 另外将目标代码段之前的100 bytes的代码全部都填满NOP指令. 这样无论跳转到哪一条NOP指令, 程序都会顺势滑行到目标代码段了</li>\n<li>有的时候, 代码中出现了条件转移, 会先判断一个标志位根据结果再判断是否转移. 现在假设某一个程序员想测试这段汇编代码, 去掉这个”判断”操作, 那么只要把那条判断指令改写成NOP就可以了. (这也是破解正版软件的常见招数)</li>\n</ul>\n<p>更多转载：<a href=\"https://www.zhihu.com/question/21122634\">NOP指令会打断CPU流水线吗？ - 知乎 (zhihu.com)</a></p>\n<p><strong>指令封锁前缀指令：LOCK</strong></p>\n<p>格式：LOCK XXX;      XXX代表指令</p>\n<p>作为一个指令前缀，可以放在任何指令前，这个前缀使得在这个指令执行时间内，8086处理器得封锁输出引脚（LOCK）有效，使别的控制器不能控制总线，直到该指令执行完后，总线封锁解除；</p>\n<p>注意LOCK指令前缀只是见于常见的汇编指令体系，而并不是存在于所有的汇编指令体系中，即有些汇编指令体系中用等价的设计来获得LOCK指令前缀提供的功能；且并不是所有的汇编指令都能被LOCK指令前缀修饰，不同汇编指令体系下允许被LOCK指令前缀修饰的汇编指令集不尽相同；</p>\n<p>被LOCK修饰得汇编指令变成原子操作指令(当且仅当操作物理或者逻辑不可中断（不可中断：操作所涉内存不可被读取和修改）时，该操作才是原子的)；</p>\n<p>被修饰的指令在执行期间通过内存总线传递一个LOCK信号，该信号使内存封锁，此时这个内存不能被其他汇编指令所操作，直到被修饰的指令执行完毕，<u>等价于该修饰指令执行时其他所有汇编指令暂停执行</u>；</p>\n<p>具有内存屏障的功能：</p>\n<ul>\n<li>禁止重排序</li>\n<li>刷新缓存到内存</li>\n<li>使缓存失效</li>\n</ul>\n<p><strong>暂停指令：HLT</strong></p>\n<p>格式：HLT</p>\n<p>使CPU处于暂停状态，指令执行时，CPU反复执行NOP，等待复位，中断或DMA操作信号；该指令往往用在程序等待中断的位置，一旦中断返回，CPU脱离暂停状态，继续执行HLT的下一条指令；</p>\n<p>此指令不影响标志位，只能通过reset、NMI（非屏蔽中断请求）、intr（屏蔽外部中断请求）信号RET返回指令；</p>\n<p><strong>交权指令：ESC</strong></p>\n<p>格式：ESC 存储器寻址方式</p>\n<p>把浮点指令交给浮点处理器，浮点协处理器8087指令是与8086的指令组合在一起的，当8086发现这是一条浮点指令时，利用ESC指令将浮点指令交给8087处理；</p>\n<p><em>FPU：浮点处理单元</em></p>\n<p><strong>等待指令：WAIT</strong></p>\n<p>格式：WAIT</p>\n<p>用于于8087同步，由于8087执行浮点指令较慢，8086必须与8087保持同步；</p>\n<p>高电平保存WAIT状态，低电平退出WAIT状态；</p>\n<p>更多：<a href=\"http://www.weijiyuanli.cn/_cai/cbiancheng/asm/90/index.html\">汇编语言字符串和数组- 汇编语言程序设计 - 春软虚拟实验室vlab.cn (weijiyuanli.cn)</a></p>\n<p><strong>标志操作指令</strong></p>\n<p>格式：</p>\n<ul>\n<li><p>CLC:进位标志指令<strong>CLC</strong>(Clear Carry Flag),影响CF = 0;</p>\n</li>\n<li><p>STC:进位标志指令<strong>STC</strong>(SeT Carry Flag),影响CF = 1;</p>\n</li>\n<li><p>CMC:进位标志取反指令<strong>CMC</strong>(CoMplement Carry flag)如果CF = 1，则执行后CF = 0;如果CF = 0，则执行后CF = 1;</p>\n</li>\n<li><p>CLD:方向标志<strong>CLD</strong>(CLear Direction flag),影响DF = 0;</p>\n</li>\n<li><p>STD:方向标志<strong>STD</strong>(SeT Direction flag),影响DF = 1;</p>\n</li>\n<li><p>CLI:中断允许标志<strong>CLI</strong>(CLear Interrupt enable flag),影响IF = 0;</p>\n</li>\n<li><p>STI:断标志<strong>STI</strong>(SeT interrupt enable flag),影响IF = 1;</p>\n</li>\n</ul>\n"},{"title":"文件","url":"/2022/12/04/%E6%96%87%E4%BB%B6/","content":""},{"title":"汇编语言note.8","url":"/2023/04/21/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80note.8/","content":"<h3 id=\"输入-输出指令\"><a href=\"#输入-输出指令\" class=\"headerlink\" title=\"输入/输出指令\"></a>输入/输出指令</h3><p>输入/输出指令时控制CPU与外设交换数据的指令;</p>\n<p><strong>IN</strong>：数据由端口到CPU；</p>\n<p><strong>OUT</strong>：数据由CPU到端口；</p>\n<p>在IN/OUT指令中，只能用AX或者AL寄存器来存放从端口读入的数据或者要发到端口中的数据；</p>\n<p>输入格式：</p>\n<p>n为8位的端口地址；</p>\n<ul>\n<li><p>IN AL,n 表示从端口地址为n的地址读取一字节数据到AL</p>\n</li>\n<li><p>IN AX,n 表示从端口地址n读取1字节数据到AL，从端口地址n+1读取1字节到AH</p>\n</li>\n</ul>\n<p>当端口地址为16位时，应将16位端口地址送入DX寄存器中；</p>\n<ul>\n<li><p>IN AL,DX 将DX作为端口地址中的内容送到AL</p>\n</li>\n<li><p>IN AX,DX 将DX作为端口地址中的内容送到AL，将（DX+1）的端口地址内容送AH</p>\n<p>输出格式：</p>\n</li>\n</ul>\n<p>n为8位端口地址，DX为16位端口地址；</p>\n<ul>\n<li><p>OUT n，AL</p>\n</li>\n<li><p>OUT n，AX</p>\n</li>\n<li><p>OUT DX，AL</p>\n</li>\n<li><p>OUT DX，AX</p>\n</li>\n</ul>\n<p>具体方法和含义同上</p>\n<p>输入/输出指令不影响标志位；</p>\n<p><strong>中断指令</strong></p>\n<p>一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。我们在编程的时候，可以用int指令调用这些子程序。</p>\n<p>中断是一种改变程序执行顺序的方法；</p>\n<p>中断：CPU暂停现行的程序，转去处理I/O设备的请求，或者某些紧急事件，处理完后CPU返回原来的程序并运行，这个处理过程叫做中断；</p>\n<p>引起中断的事件或设备叫做<strong>中断源</strong>，被中断的地方叫<strong>断点</strong>，CPU被中断后转去执行的程序叫<strong>中断处理程序(中断例程)或中断子程序</strong>；</p>\n<p>中断系统的功能：能实现中断响应，中断服务和中断返回；能实现中断优先级排队，优先级高的先处理；能实现中断嵌套；</p>\n<p>一个完整的中断基本过程包括：<strong>中断请求</strong>、<strong>中断判优</strong>、<strong>中断响应</strong>、<strong>中断处理</strong>及<strong>中断返回</strong>等五个基本过程。</p>\n<p>具体：<a href=\"https://blog.csdn.net/Anpache/article/details/120751481\">汇编语言—中断 (8259A)_中断类型码_Anpache的博客-CSDN博客</a></p>\n<p>中断向量表：存放中断地址的一段内存空间称中断向量表，表的地址位于内存的0000H~03FFH，1KB大小，共256个入口每个入口占用4个单元，依次位IP：CS，低字节为段内偏移，高字节为段基址；</p>\n<p>0~FH为专用中断，10~1FH为BIOS中断，20H~3FH为DOS中断，40H~5FH 保留，60H~67H为用户中断，68H~7FH 保留,80H~85H 由BASIC保留，86H~F0H BASIC中断，F1H~FFH 保留；</p>\n<p>中断处理程序的入口地址=中断类型号*4个字节；</p>\n<p>   中断类型：</p>\n<ul>\n<li>外部非屏蔽中断(<strong>NMI</strong>)，中断源来自CPU之外，不受内部中断允许标志位IF的控制，通常情况下CPU必须响应这类中断，一般在一个系统中只允许一个非屏蔽中断；</li>\n<li>外部可屏蔽中断(<strong>INTR</strong>)：中断源来自CPU之外，受IF的控制，只有IF=1时，CPU才响应该中断，当IF=0时，中断请求被屏蔽；</li>\n<li>内部中断（软件中断）：CPU根据某些指令或者程序对标识符的设置而产生的中断请求，与外部电路无关，是自身引发的中断事件，内部中断有四种：</li>\n</ul>\n<p>1.除法错中断：被0除或除法溢出（0号中断）；</p>\n<p>2.单步中断：当单步标志符TF=1时，每执行一条指令后产生单步中断（1号中断）；</p>\n<p>3.溢出中断：执行中断指令<strong>INTO</strong>时，如OF=1，则产生溢出中断（4号中断）；</p>\n<p>4.<strong>INT</strong>指令中断：执行中断调用指令<strong>INT</strong>  n，产生指令中断，其中n=0~255；</p>\n<p>中断指令：<strong>INT</strong></p>\n<p>格式：INT n </p>\n<p>产生n号中断，n为8位立即数；</p>\n<p>功能：将标志寄存器入栈保护，把<strong>IF</strong>和<strong>TF</strong>置为0，把当前地址入栈保护，通过n转到中断程序的地址，n×4作为ip参数，n×4+2作为cs参数；</p>\n<p>溢出中断指令：<strong>INTO</strong></p>\n<p>格式：INTO</p>\n<p>若OF=1，说明发生溢出，产生4号中断，否则顺序执行，OF=0时本指令不起中断调用指令；</p>\n<p>中断返回指令：<strong>IRET</strong></p>\n<p>格式：<strong>IRET</strong></p>\n<p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序;</p>\n"},{"title":"看板娘","url":"/2022/10/01/%E7%9C%8B%E6%9D%BF%E5%A8%98/","content":"<h2 id=\"一、安装hexo-helper-live2d-插件\"><a href=\"#一、安装hexo-helper-live2d-插件\" class=\"headerlink\" title=\"一、安装hexo-helper-live2d 插件\"></a>一、安装hexo-helper-live2d 插件</h2><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">npm install --save hexo-helper-live2d<br></code></pre></td></tr></table></figure>\n<h2 id=\"二、下载live2d模型\"><a href=\"#二、下载live2d模型\" class=\"headerlink\" title=\"二、下载live2d模型\"></a>二、下载live2d模型</h2><p>下面给出看板娘模型的名单和预览图，你可以挑一个想要的</p>\n<p>预览图：<a href=\"https://link.zhihu.com/?target=https%3A//huaji8.top/post/live2d-plugin-2.0/\">https://huaji8.top/post/live2d-plugin-2.0/</a></p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">live2d-widget-model-chitose<br>live2d-widget-model-epsilon2_1<br>live2d-widget-model-gf<br>live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)<br>live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)<br>live2d-widget-model-haruto<br>live2d-widget-model-hibiki<br>live2d-widget-model-hijiki<br>live2d-widget-model-izumi<br>live2d-widget-model-koharu<br>live2d-widget-model-miku<br>live2d-widget-model-ni-j<br>live2d-widget-model-nico<br>live2d-widget-model-nietzsche<br>live2d-widget-model-nipsilon<br>live2d-widget-model-nito<br>live2d-widget-model-shizuku<br>live2d-widget-model-tororo<br>live2d-widget-model-tsumiki<br>live2d-widget-model-unitychan<br>live2d-widget-model-wanko<br>live2d-widget-model-z16<br></code></pre></td></tr></table></figure>\n<p>然后执行指令↓</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">npm install live2d-widget-model-koharu //假设你选择的看板娘是koharu<br></code></pre></td></tr></table></figure>\n<h2 id=\"三、修改-config-yml配置文件\"><a href=\"#三、修改-config-yml配置文件\" class=\"headerlink\" title=\"三、修改_config.yml配置文件\"></a>三、修改_config.yml配置文件</h2><p>找到你博客的本地存储的根目录，打开_config.yml文件，添加下面的内容</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">#Live2D动画<br>live2d:<br>  enable: true<br>  scriptFrom: local<br>  pluginRootPath: live2dw/<br>  pluginJsPath: lib/<br>  pluginModelPath: assets/<br>  tagMode: false<br>  debug: false<br>  model:<br>    use: live2d-widget-model-koharu <br>  display:<br>    position: right <br>    width: 150<br>    height: 300<br>  mobile:<br>    show: true<br></code></pre></td></tr></table></figure>\n<h2 id=\"四、主要参数说明\"><a href=\"#四、主要参数说明\" class=\"headerlink\" title=\"四、主要参数说明\"></a>四、主要参数说明</h2><ol>\n<li>enable //是否使用</li>\n<li>model:<br>use: live2d-widget-model-koharu //要使用的模型名称</li>\n<li>display:<br>position: right //显示的位置<br>width: 150 //宽度<br>height: 150 //高度<br>mobile:<br>show: true //移动端是否显示</li>\n</ol>\n<h2 id=\"五、调试-amp-部署\"><a href=\"#五、调试-amp-部署\" class=\"headerlink\" title=\"五、调试&amp;部署\"></a>五、调试&amp;部署</h2><p>在你已经安装git环境的基础上，在博客的本地存储根目录下右键-&gt;Git Bash Here</p>\n<p>依次输入↓</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">hexo clean<br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure>\n<p>现在你就可以在本地预览一下自己的博客精灵啦，打开浏览器登录：<strong>localhost:4000</strong></p>\n<p>或者，<a href=\"https://link.zhihu.com/?target=http%3A//localhost%3A4000/\">点击这里</a>~</p>\n<p>相中好看板娘之后，就可以部署到GitHub pages上了</p>\n<p>回到git，输入下面的指令并成功登录后…</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">hexo d<br></code></pre></td></tr></table></figure>\n"}]