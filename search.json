[{"title":"C语言划水日记（1）","url":"/2022/09/28/C%E8%AF%AD%E8%A8%80%E5%88%92%E6%B0%B4%E6%97%A5%E8%AE%B0%EF%BC%881%EF%BC%89/","content":"<h1 id=\"一：基本数据类型的分类\"><a href=\"#一：基本数据类型的分类\" class=\"headerlink\" title=\"一：基本数据类型的分类\"></a>一：基本数据类型的分类</h1><h2 id=\"1-整形\"><a href=\"#1-整形\" class=\"headerlink\" title=\"1.整形\"></a>1.整形</h2><h3 id=\"有符号数：\"><a href=\"#有符号数：\" class=\"headerlink\" title=\"有符号数：\"></a>有符号数：</h3><h5 id=\"1-short-int或short：-32768-32767-2-15-2-15-1\"><a href=\"#1-short-int或short：-32768-32767-2-15-2-15-1\" class=\"headerlink\" title=\"(1)short int或short：-32768~32767(2^15~2^15 -1)\"></a>(1)short int或short：-32768~32767(2^15~2^15 -1)</h5><h5 id=\"2-int-2147483648-2147483647（-2-31-2-31-1）\"><a href=\"#2-int-2147483648-2147483647（-2-31-2-31-1）\" class=\"headerlink\" title=\"(2)int: -2147483648~2147483647（-2^31~2^31 -1）\"></a>(2)int: -2147483648~2147483647（-2^31~2^31 -1）</h5><h5 id=\"3-long-int或long-2147483648-2147483647（-2-31-2-31-1）\"><a href=\"#3-long-int或long-2147483648-2147483647（-2-31-2-31-1）\" class=\"headerlink\" title=\"(3)long int或long: -2147483648~2147483647（-2^31~2^31-1）\"></a>(3)long int或long: -2147483648~2147483647（-2^31~2^31-1）</h5><h3 id=\"无符号数\"><a href=\"#无符号数\" class=\"headerlink\" title=\"无符号数\"></a>无符号数</h3><h5 id=\"1-unsigned-short-0-65535（0-2-16-1）\"><a href=\"#1-unsigned-short-0-65535（0-2-16-1）\" class=\"headerlink\" title=\"(1)unsigned short: 0~65535（0~2^16-1）\"></a>(1)unsigned short: 0~65535（0~2^16-1）</h5><h5 id=\"2-unsigned-0-4294967295（0-2-32-1）\"><a href=\"#2-unsigned-0-4294967295（0-2-32-1）\" class=\"headerlink\" title=\"(2)unsigned: 0~4294967295（0~2^32-1）\"></a>(2)unsigned: 0~4294967295（0~2^32-1）</h5><h5 id=\"3-unsigned-long-0-4294967295（0-2-32-1）\"><a href=\"#3-unsigned-long-0-4294967295（0-2-32-1）\" class=\"headerlink\" title=\"(3)unsigned long: 0~4294967295（0~2^32-1）\"></a>(3)unsigned long: 0~4294967295（0~2^32-1）</h5><h2 id=\"2-浮点型\"><a href=\"#2-浮点型\" class=\"headerlink\" title=\"2.浮点型\"></a>2.浮点型</h2><h5 id=\"1-单-精-度-float-3-4E-38～3-4E-38-7位有效数字\"><a href=\"#1-单-精-度-float-3-4E-38～3-4E-38-7位有效数字\" class=\"headerlink\" title=\"(1)单 精 度: float: -3.4E-38～3.4E+38   7位有效数字\"></a>(1)单 精 度: float: -3.4E-38～3.4E+38   7位有效数字</h5><h5 id=\"1-双-精-度-double-1-7E-308～1-7E-308-16位有效数字\"><a href=\"#1-双-精-度-double-1-7E-308～1-7E-308-16位有效数字\" class=\"headerlink\" title=\"(1)双 精 度: double: -1.7E-308～1.7E+308   16位有效数字\"></a>(1)双 精 度: double: -1.7E-308～1.7E+308   16位有效数字</h5><h5 id=\"1-长双精度-long-double-3-4E-308～3-4E-308-19位有效数字\"><a href=\"#1-长双精度-long-double-3-4E-308～3-4E-308-19位有效数字\" class=\"headerlink\" title=\"(1)长双精度: long double: -3.4E-308～3.4E+308   19位有效数字\"></a>(1)长双精度: long double: -3.4E-308～3.4E+308   19位有效数字</h5><h2 id=\"3-字符型\"><a href=\"#3-字符型\" class=\"headerlink\" title=\"3.字符型\"></a>3.字符型</h2><h5 id=\"1-字符：-char\"><a href=\"#1-字符：-char\" class=\"headerlink\" title=\"(1)字符： char\"></a>(1)字符： char</h5><h1 id=\"二：常量和变量\"><a href=\"#二：常量和变量\" class=\"headerlink\" title=\"二：常量和变量\"></a>二：常量和变量</h1><h4 id=\"常量定义：\"><a href=\"#常量定义：\" class=\"headerlink\" title=\"常量定义：\"></a>常量定义：</h4><p>程序运行时其值不能改变的量（即常数）</p>\n<h4 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类:\"></a>分类:</h4><h4 id=\"符号常量-用标识符代表常量定义格式：-define-符号常量-常量\"><a href=\"#符号常量-用标识符代表常量定义格式：-define-符号常量-常量\" class=\"headerlink\" title=\"符号常量:   用标识符代表常量定义格式： #define   符号常量   常量\"></a>符号常量:   用标识符代表常量定义格式： #define   符号常量   常量</h4><h4 id=\"直接常量\"><a href=\"#直接常量\" class=\"headerlink\" title=\"直接常量:\"></a>直接常量:</h4><p>​    整型常量   实型常量    字符常量   字符串常量</p>\n<h4 id=\"字符常量：用单引号括起来的单个普通字符或转义字符\"><a href=\"#字符常量：用单引号括起来的单个普通字符或转义字符\" class=\"headerlink\" title=\"字符常量：用单引号括起来的单个普通字符或转义字符\"></a>字符常量：用单引号括起来的单个普通字符或转义字符</h4><h4 id=\"字符常量的值：该字符的ASCII码值\"><a href=\"#字符常量的值：该字符的ASCII码值\" class=\"headerlink\" title=\"字符常量的值：该字符的ASCII码值\"></a>字符常量的值：该字符的ASCII码值</h4><h4 id=\"转义字符-反斜线后面跟一个字符或一个代码值表示\"><a href=\"#转义字符-反斜线后面跟一个字符或一个代码值表示\" class=\"headerlink\" title=\"转义字符:反斜线后面跟一个字符或一个代码值表示\"></a>转义字符:反斜线后面跟一个字符或一个代码值表示</h4><p>\\n:换行；                                       \\t:水平制表: </p>\n<p>\\v:垂直制表;                                   \\b:退格; </p>\n<p>\\r:回车;                                            \\f:换页; </p>\n<p>\\a:响铃;                                            \\\\:反斜线; </p>\n<p>\\‘:单引号;                                          \\“:双引号; </p>\n<p> \\ddd：3位8进制数代表的字符； \\xhh： 2位16进制数代表的字符；</p>\n<h4 id=\"字符串常量\"><a href=\"#字符串常量\" class=\"headerlink\" title=\"字符串常量:\"></a>字符串常量:</h4><p>定义：用双引号(“”)括起来的字符序列</p>\n<p>存储：每个字符串尾自动加一个 ‘\\0’ 作为字符</p>\n<h2 id=\"变量概念：其值可以改变的量\"><a href=\"#变量概念：其值可以改变的量\" class=\"headerlink\" title=\"变量概念：其值可以改变的量\"></a>变量概念：其值可以改变的量</h2><h4 id=\"变量三要素：变量名、变量类型和变量值\"><a href=\"#变量三要素：变量名、变量类型和变量值\" class=\"headerlink\" title=\"变量三要素：变量名、变量类型和变量值\"></a>变量三要素：变量名、变量类型和变量值</h4><h4 id=\"变量定义的一般格式：-数据类型-变量1-，变量2，…，变量n\"><a href=\"#变量定义的一般格式：-数据类型-变量1-，变量2，…，变量n\" class=\"headerlink\" title=\"变量定义的一般格式：     数据类型  变量1[，变量2，…，变量n];\"></a>变量定义的一般格式：     数据类型  变量1[，变量2，…，变量n];</h4><h3 id=\"常变量-const-数据类型-常变量名-初始值\"><a href=\"#常变量-const-数据类型-常变量名-初始值\" class=\"headerlink\" title=\"常变量: const 数据类型 常变量名=初始值\"></a>常变量: const 数据类型 常变量名=初始值</h3>","tags":["3"]},{"title":"Hello World","url":"/2022/09/25/hello-world/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">mathjax: true<br></code></pre></td></tr></table></figure>\n<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"变量与相关关键字","url":"/2022/11/24/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/","content":"<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>作用域是指变量的有效范围，即变量可以在哪个范围以内使用；变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的</p>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><p>定义在函数内部的变量，作用域仅限于此函数内部，超出函数范围不可使用；注意函数的形参也是局部变量（Local Variable）；</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>在函数的外部定义的变量称为全局变量（Global Variable）；默认作用域是整个程序，即所有的代码文件，包括源文件（<strong>.c</strong>文件）和头文件（<strong>.h</strong>文件）;</p>\n<p>说明：在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。</p>\n<h6 id=\"如果某个函数内部局部变量和全局变量同名，则在当前函数中全局变量不起作用；\"><a href=\"#如果某个函数内部局部变量和全局变量同名，则在当前函数中全局变量不起作用；\" class=\"headerlink\" title=\"如果某个函数内部局部变量和全局变量同名，则在当前函数中全局变量不起作用；\"></a>如果某个函数内部局部变量和全局变量同名，则在当前函数中全局变量不起作用；</h6><p>变量的使用遵循就近原则，如果在当前的局部作用域中找到了同名变量，就不会再去更大的全局作用域中查找。</p>\n<h4 id=\"局部变量与全局变量\"><a href=\"#局部变量与全局变量\" class=\"headerlink\" title=\"局部变量与全局变量\"></a>局部变量与全局变量</h4><p>定义时全局变量的值为0，而局部变量的值时随机的；</p>\n<p>两者的作用域不同；</p>\n<p>全局变量分配在数据段（数据段存的是数）上，而局部变量分配在栈上面；</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p>auto：在声明局部变量时，不加关键字均默认为auto，变量与数据分配在动态存储区；</p>\n<p>static：声明时在局部变量的类型前加该关键字，表示该局部变量是“静态局部变量”，这样在函数的调用结束后该变量不会消失，即占用的内存空间不会释放，下一次函数调用时该变量的值为上一次函数结束时的值；</p>\n<p>register：在声明动态局部变量或者函数形参时，可将变量声明为register，这样编译系统就会为变量分配一个寄存器而不是内存空间，通过这种方式可提升对某些局部变量频繁调用的程序的性能。（寄存器运算速度远高于内存）</p>\n<p>extern：对于一个文件内，extern声明的变量相当于告诉编译器该变量是存在的，但不在该调用位置的前面，即定义在该调用之后，相当于扩大该变量的作用域；（真正的作用）对于不是同一个文件，可以引用不是同一个文件的变量（需为全局变量）和函数，另外extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，而关于函数的引用，需要注意的就是，需要指明返回值的类型和参数。</p>\n<h4 id=\"静态变量与动态变量\"><a href=\"#静态变量与动态变量\" class=\"headerlink\" title=\"静态变量与动态变量\"></a>静态变量与动态变量</h4><p>定义或者声明变量时，没有static修饰符的就是动态变量，有static修饰符的就是静态变量；</p>\n<p><strong>静态全局变量</strong>：动态全局变量可以通过extern关键字在外部文件中使用，但静态全局变量不可以在外部文件中使用，静态全局变量相当于限制了动态全局变量的作用域。</p>\n<p><strong>静态局部变量</strong>：静态局部变量的生命周期是到程序的结束，而动态局部变量的生命周期是函数的结束，静态局部变量的生命周期更长，同时静态局部变量只会初始化一次，函数重复调用，但静态局部变量不会被重新初始化。</p>\n"},{"title":"宏定义","url":"/2022/11/22/%E5%AE%8F%E5%AE%9A%E4%B9%89/","content":"<h1 id=\"无参宏：宏名后不带参数\"><a href=\"#无参宏：宏名后不带参数\" class=\"headerlink\" title=\"无参宏：宏名后不带参数\"></a>无参宏：宏名后不带参数</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs #define\">#define 宏名 替代的文本<br></code></pre></td></tr></table></figure>\n<p>每个#define行（即逻辑行）由三部分组成：</p>\n<p>第一部分是指令 <strong>#define</strong> 自身，“<strong>#</strong>”表示这是一条预处理命令，“<strong>define</strong>”为宏命令；</p>\n<p>第二部分为宏，一般为缩略语，其名称（宏名）一般大写，而且不能有空格，遵循C变量命令规则。“替换文本”可以是任意常数、表达式、字符串等；</p>\n<p>第三部分是替换的文本，在预处理工作过程中，代码中所有出现的“宏名”，都会被“替换的文本”替换。这个替换的过程被称为“宏代换”或“宏展开”。“宏代换”是由预处理程序自动完成的。在C语言中，“宏”分为两种：无参数 和 有参数。</p>\n<p>“<strong>#</strong>”可以不在行首，但只允许它前面有空格符；</p>\n<p> 标识符和替换列表之间不能加赋值号 =，替换列表后不能加分号；</p>\n<p>如果要写宏不止一行，则在结尾加反斜线符号使得多行能连接上，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">#define HELLO &quot;hello \\<br>the world&quot;<br></code></pre></td></tr></table></figure>\n<p>注意：行与行之间的空格也会被作为替换文本的一部分；</p>\n<p>宏名如果出现在源程序中的 “ ”（括号）内，则不会被当做宏来进行宏代换；</p>\n<p>宏可以嵌套，但不参与运算；</p>\n<p>宏定义必须写在函数之外，其作用域是 #<strong>define</strong> 开始，到源程序结束。如果要提前结束它的作用域则用 #<strong>undef 标识符</strong> 命令；</p>\n<p>可以用宏定义表示数据类型，可以使代码简便：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">#define STU struct Student      // 宏定义STU<br>struct Student&#123;                 // 定义结构体Student<br>    char *name;<br>    int sNo;<br>&#125;;<br>STU stu = &#123;&quot;Jack&quot;, 20&#125;;         // 被替换为：struct Student stu = &#123;&quot;Jack&quot;, 20&#125;;<br>printf(&quot;name: %s, sNo: %d\\n&quot;, stu.name, stu.sNo);<br></code></pre></td></tr></table></figure>\n<h1 id=\"有参宏\"><a href=\"#有参宏\" class=\"headerlink\" title=\"有参宏\"></a>有参宏</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">#define 宏名（参数，参数···） 替换主体（表达式）<br></code></pre></td></tr></table></figure>\n<p>和函数类似，在宏定义中的参数成为形式参数，在宏调用中的参数成为实际参数。</p>\n<p>而且和无参宏不同的一点是，有参宏在调用中，不仅要进行宏展开，而且还要用实参去替换形参。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> M 5                          <span class=\"hljs-comment\">//无参宏</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> COUNT(M) M * M               <span class=\"hljs-comment\">//有参宏</span></span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;COUNT = %d\\n&quot;</span>, COUNT(<span class=\"hljs-number\">10</span>));   <span class=\"hljs-comment\">// 替换为： COUNT(10) = 10 * 10</span><br>                                     <span class=\"hljs-comment\">// 输出结果： COUNT = 100</span><br></code></pre></td></tr></table></figure>\n<p>这看上去用法与函数调用类似，但实际上是有很大差别的。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> COUNT(M) M * M               <span class=\"hljs-comment\">//定义有参宏</span></span><br><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">6</span>;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;COUNT = %d\\n&quot;</span>, COUNT(x + <span class=\"hljs-number\">1</span>));<span class=\"hljs-comment\">// 输出结果： COUNT = 13</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;COUNT = %d\\n&quot;</span>, COUNT(++x));  <span class=\"hljs-comment\">// 输出结果： COUNT = 56                                                                                               //warning:... main.c:161:34: Multiple unsequenced             modifications to &#x27;x&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>这两个结果和调用函数的方法的结果差别很大，因为如果是像函数那样的话，COUNT(x + 1)应该相当于COUNT(7)，结果应该是 7 <em> 7 = 49，但输出结果却是21。原因在于，预处理器不进行技术，只是进行字符串替换，而且也不会自动加上括号（），所以COUNT(x + 1)被替换为 COUNT(x + 1 </em> x + 1)，代入 x = 6，即为 6 + 1 * 6 + 1 = 13。而解决办法则是：尽量用括号把整个替换文本及其中的每个参数括起来：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> COUNT(M) ((M) * (M))  </span><br></code></pre></td></tr></table></figure>\n<p>但即使用括号，也不能解决上面例子的最后一个情况，COUNT(++x) 被替换为 ++x <em> ++x，即为 7 </em> 8 = 56，而不是想要 7 * 7 = 49，解决办法最简单的是：不要在有参宏用使用到“++”、“–”等。</p>\n<p>上面说到宏名中不能有空格，宏名与形参表之间也不能有空格，而形参表中形参之间可以出现空格：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SUM (a,b) a + b              <span class=\"hljs-comment\">//定义有参宏</span></span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;SUM = %d\\n&quot;</span>, SUM(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>));      <span class=\"hljs-comment\">//调用有参宏。Build Failed！</span><br>因为 SUM 被替换为：(a,b) a + b<br></code></pre></td></tr></table></figure>\n<p>如果用函数求一个整数的平方，则是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">count</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>所以在宏定义中：#define COUNT(M) M * M 中的形参不分配内存单元，所以不作类型定义。而函数 int count(int x)中形参是局部变量，会在栈区分配内存单元，所以要作类型定义，而且实参与形参之间是“值传递”。而宏只是符号代换，不存在值传递。</p>\n<p>宏定义也可以用来定义表达式或者多个语句。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> JI(a,b) a = i + 3; b = j + 5;   <span class=\"hljs-comment\">//宏定义多个语句</span></span><br><span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">5</span>, j = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">0</span>, n = <span class=\"hljs-number\">0</span>;<br>JI(m, n);                               <span class=\"hljs-comment\">// 宏代换后为： m = i + 3, n = j + 5;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;m = %d, n = %d\\n&quot;</span>, m, n);       <span class=\"hljs-comment\">// 输出结果为： m = 8, n = 15</span><br></code></pre></td></tr></table></figure>\n<p><strong>3、# 运算符</strong></p>\n<p>比如如果我们宏定义了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SUM (a,b) ((a) + (b)) </span><br></code></pre></td></tr></table></figure>\n<p>我们想要输出“1 + 2 + 3 + 4 = 10”，用以下方式显得比较麻烦，有重复代码，而且中间还有括号：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;(%d + %d) + (%d + %d) = %d\\n&quot;</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, SUM(<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>+ <span class=\"hljs-number\">4</span>));<br></code></pre></td></tr></table></figure>\n<p>那么这时可以考虑用 # 运算符来在字符串中包含宏参数，# 运算符的用处就是把语言符号转化为字符串。例如，如果 a 是一个宏的形参，则替换文本中的 #a 则被系统转化为 “a”。而这个转化的过程成为 “字符串化（stringizing）”。用这个方法实现上面的要求：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SUM(a,b) printf(#a <span class=\"hljs-string\">&quot; + &quot;</span>#b<span class=\"hljs-string\">&quot; = %d\\n&quot;</span>,((a) + (b)))    <span class=\"hljs-comment\">//宏定义，运用 # 运算符</span></span><br>SUM(<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span>);                                          <span class=\"hljs-comment\">//宏调用</span><br><span class=\"hljs-comment\">//输出结果：1 + 2 + 3 + 4 = 10</span><br></code></pre></td></tr></table></figure>\n<p>调用宏时，用 1 + 2 代替 a，用 3 + 4 代替b，则替换文本为：printf(“1 + 2” ” + ” “3 + 4” ” = %d\\n”,((1 + 2) + (3 + 4)))，接着字符串连接功能将四个相邻的字符串转换为一个字符串：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-string\">&quot;1 + 2 + 3 + 4 = %d\\n&quot;</span><br></code></pre></td></tr></table></figure>\n<p><strong>4、## 运算符</strong></p>\n<p>和 # 运算符一样，## 运算符也可以用在替换文本中，而它的作用是起到粘合的作用，即将两个语言符号组合成一个语言符号，所以又称为“预处理器的粘合剂（Preprocessor Glue）”。用法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> NAME(n) num ## n            <span class=\"hljs-comment\">//宏定义，使用 ## 运算符</span></span><br><span class=\"hljs-type\">int</span> num0 = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;num0 = %d\\n&quot;</span>, NAME(<span class=\"hljs-number\">0</span>));     <span class=\"hljs-comment\">//宏调用</span><br></code></pre></td></tr></table></figure>\n<p>NAME(0)被替换为 num ## 0，被粘合为： num0。</p>\n<p><strong>5、可变宏：… 和 <strong>VA_ARGS</strong></strong></p>\n<p>我们经常要输出结果时要多次使用 prinf(“…”, …); 如果用上面例子#define SUM(a,b) printf(#a ” + “#b” = %d\\n”,((a) + (b)))，则格式比较固定，不能用于输出其他格式。</p>\n<p>这时我们可以考虑用可变宏（Variadic Macros）。用法是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PR(...) printf(__VA_ARGS__)     <span class=\"hljs-comment\">//宏定义</span></span><br>PR(<span class=\"hljs-string\">&quot;hello\\n&quot;</span>);                          <span class=\"hljs-comment\">//宏调用</span><br><span class=\"hljs-comment\">//输出结果：hello</span><br></code></pre></td></tr></table></figure>\n<p>在宏定义中，形参列表的最后一个参数为省略号“…”，而“<strong>VA_ARGS</strong>”就可以被用在替换文本中，来表示省略号“…”代表了什么。而上面例子宏代换之后为： printf(“hello\\n”);</p>\n<p>还有个例子如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PR2(X, ...) printf(<span class=\"hljs-string\">&quot;Message&quot;</span>#X<span class=\"hljs-string\">&quot;:&quot;</span>__VA_ARGS__)   <span class=\"hljs-comment\">//宏定义</span></span><br><span class=\"hljs-type\">double</span> msg = <span class=\"hljs-number\">10</span>;<br>PR2(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;msg = %.2f\\n&quot;</span>, msg);                            <span class=\"hljs-comment\">//宏调用</span><br><span class=\"hljs-comment\">//输出结果：Message1:msg = 10.00</span><br></code></pre></td></tr></table></figure>\n<p>在宏调用中，X的值为1，所以 #X 被替换为”1”。宏代换后为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Message&quot;</span><span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-string\">&quot;:&quot;</span><span class=\"hljs-string\">&quot;msg = %.2f\\n&quot;</span>, msg);<br></code></pre></td></tr></table></figure>\n<p>接着这4个字符串连接成一个：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Message1:msg = %.2f\\n&quot;</span>, msg);<br></code></pre></td></tr></table></figure>\n<p>要注意的是：省略号“…”只能用来替换宏的形参列表中最后一个！</p>\n"},{"title":"快速排序","url":"/2022/10/11/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":"<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>\n<p>该方法的基本思想是：</p>\n<ul>\n<li>1．先从数列中取出一个数作为基准数。//<em>一般是中间值</em></li>\n<li>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>\n<li>3．再对左右区间重复第二步，直到各区间只有一个数。</li>\n</ul>\n<p>并且快速排序还有一个比较简单的思想，就是递归。对于每一趟排序都是一样的思想，只不过需要进行排序的数组的范围越来越小了，使用递归实现这种排序最适合不过了。</p>\n<h2 id=\"快速排序的特点及性能\"><a href=\"#快速排序的特点及性能\" class=\"headerlink\" title=\"快速排序的特点及性能\"></a>快速排序的特点及性能</h2><p>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。  </p>\n<p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 <code>O(n2)</code>，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 <code>O(nlogn)</code>，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。  </p>\n<p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 <code>O(logn)</code>，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 <code>O(n)</code>。所以我们一般认为快速排序的空间复杂度为 <code>O(logn)</code>。  </p>\n<p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。  </p>\n<p>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>取数组的中间值作为基准值， 这组数据中取中间值1为基准值，</p>\n<p>设i=1,j=10,a[i]=7,a[10]=0,mid=5,a[mid]=1;</p>\n<p>寻找比中值(a[mid]=1)大的数，即i=1;接着寻找比中值小的数，即j=10；</p>\n<p>将a[i=1]=7与a[j=10]=0交换，同时i++,j—，即此时i=2,j=9;此时数组为</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>因为i与j还未相遇，即i与J之间还可能存在需要交换的数字，重新进入循环，</p>\n<p>进入第二次交换时i=2,j=5,此时a[i]=2与a[j]=1交换，数组如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>接着进行i++与j—；此时i=3,j=4;因为要寻找到不大于中值(即a[mid]=1)的值，因此j—直到j=2</p>\n<p>此时i&gt;=j因此不进行交换且结束循环，进入递归；进入递归前可发现大于中值的在中值的右边，小于中值的在中值左边；</p>\n<p>记住此时的i=3,j=2;</p>\n<p>先从左边递归，即在i=1和j=2之间排列；中值为0；需要寻找大于或小于中值的数，此时i=2,j=1;说明不需要进行交换，并且此时i和j已经为这部分区间的边界，即这部分已经排列完成；</p>\n<p>接着返回上一步，从右边进行递归，即在i=3和j=10之间进行排列；</p>\n<p>取中值mid=6，即a[mid]=3;</p>\n<p>进行寻找大于和小于中值的值，即i=3,j=6,即a[i]=4,a[j]=3;交换a[i]与a[j]；此时数组如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>进行i++与j—，此时i=4,j=5；且此时a[i]与a[j]满足交换条件，进行交换，即</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>进行i++与j—；此时i=5,j=4，退出循环；在l=3(未排列数组的左边界)和j=4之间进行递归</p>\n<p>进行循环寻找，交换数值，此时数组如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>此时的i与j到达边界，返回上一步递归；</p>\n<p>进行右边的递归，即i=5,j=10；</p>\n<p>进行寻找，取中值mid=7,a[mid]=8,寻找大于小于中值的数，此时i=7,j=10,a[i]=8,a[j]=7;进行交换，数组如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>进行i++与j—；此时i=8,j=9;寻找符合的i与j，最后i=8,j=7,不进行交换，进入递归；</p>\n<p>先左边递归，i=5,j=7;mid=6,a[mid]=4;</p>\n<p>进行交换时i=5,j=6;数组如下；</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>到达边界，返回上一步；</p>\n<p>进行右边递归，i=8,j=10;取中值mid=9,a[mid]=12；</p>\n<p>进行交换时i=9，j=10；交换后如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>i++和j—后，i=10,j=9；接着推出循环。左边递归；</p>\n<p>此时i=8,j=9;取中值mid=8,a[mid]=9寻找相应数，进行交换，此时i=8,j=9;交换后</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>排列完成，结束退出；</p>\n<h3 id=\"具体代码（C语言）\"><a href=\"#具体代码（C语言）\" class=\"headerlink\" title=\"具体代码（C语言）\"></a>具体代码（C语言）</h3><h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include \"></a>include <stdio.h></h1><p>int a[1024];<br>void Quick_Sort(int l,int r){<br>    int i,j,mid,p;<br>    i=l,j=r,mid=a[(l+r)/2];<br>    do{<br>        while(a[i]<mid)i++;\n        while(a[j]>mid)j—;<br>        if(i&lt;=j){<br>            p=a[i],a[i]=a[j],a[j]=p;<br>            i++,j—;<br>        }<br>    }while(i&lt;=j);<br>    if(l&lt;j)ch(l,j);<br>    if(i&lt;r)ch(i,r);<br>}<br>int main(){<br>    int n;<br>    printf(“输入要输入的数的数量\\n”);<br>    scanf(“%d”,&amp;n);<br>    printf(“输入数字\\n”);<br>     for(int i=1;i&lt;=n;i++)scanf(“%d”,&amp;a[i]);<br>    Quick_Sort(1,n);<br>     for(int i=1;i&lt;=n;i++){<br>         printf(“%d “,a[i]);<br>     }<br>     return 0;<br>}</p>\n"},{"title":"指针","url":"/2022/10/17/%E6%8C%87%E9%92%88/","content":"<h1 id=\"一-指针简介\"><a href=\"#一-指针简介\" class=\"headerlink\" title=\"一.指针简介\"></a>一.指针简介</h1><p>在C语言中，数据结构存储于内存空间中，而内存空间实际是一组由有序字节组成的数组，有序字节即为这些数据结构的地址名，指针的便是保存数据结构的地址的变量，通过指针便可以更方便地对这些数据结构进行操作。</p>\n<h1 id=\"二-指针变量\"><a href=\"#二-指针变量\" class=\"headerlink\" title=\"二.指针变量\"></a>二.指针变量</h1><p>和一般变量相同，指针变量先进行定义再使用；</p>\n<p>一般形式为：</p>\n<p><em>类型说明符   </em>变量名；*</p>\n<p>其中，*表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示该指针变量所指向的变量的数据类型；</p>\n<ol>\n<li><p>普通变量的定义：定义一个普通变量，在内存空间中有一块空间存储着这个变量的值，这块空间的位置叫做地址，可以用地址操作符&amp;对变量进行操作；</p>\n</li>\n<li><p>指针变量的定义：如:int *p=NULL，这里定义一个指针变量，里面存储着一个地址，现在赋值为NULL(其实就是0，表示特殊的空地址)；</p>\n</li>\n<li><p>给指针变量赋值：如：p=&amp;a 即把a的地址赋值给p，显然直接对p的存取操作的是地址 ，通过这个地址间接操作的才是普通变量(a)。</p>\n</li>\n</ol>\n<p>赋值的方式：</p>\n<p>int <em>p=&a;  或 int </em>p;p=&a;</p>\n<p>注意不能把一个数赋予指针变量，被赋值的指针变量前不能再加“*”说明符</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">说明</th>\n<th style=\"text-align:center\">例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">定义</td>\n<td style=\"text-align:center\">int a=10;  int *p;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">赋值</td>\n<td style=\"text-align:center\">p=&a;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">间接运算</td>\n<td style=\"text-align:center\">*p=10;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指针变量直接存储的是地址</td>\n<td style=\"text-align:center\">cout&lt;&lt;p; 结果可能是地址的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指针变量间接存储的是变量值</td>\n<td style=\"text-align:center\">cout&lt;&lt;*p;  结果是10</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"三-指针的引用和运算\"><a href=\"#三-指针的引用和运算\" class=\"headerlink\" title=\"三.指针的引用和运算\"></a>三.指针的引用和运算</h1><ol>\n<li>初始化：对于定义的局部指针变量，因为其内容是随机的，直接进行操作可能会破坏程序和系统内存的值，引发不可预测的错误，所以在编程中要保证先初始化或者赋值，给与正确的地址再进行使用和操作；</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>int *p=NULL</td>\n<td>NULL是特殊的地址0，叫零指针</td>\n</tr>\n<tr>\n<td>2</td>\n<td>int *p=&amp;a</td>\n<td>p初始化为a的地址</td>\n</tr>\n<tr>\n<td>3</td>\n<td>int *p=new(int)</td>\n<td>申请一个空间给p，*p的内容不确定</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li>指针变量的+与-：因为指针变量的内容是地址，其有加与减两种常用的运算，这两个运算一般与数组进行使用操作；</li>\n</ol>\n<p>特别说明，在指针变量中“p++”的意思是“广义的加1”，不是p的值(地址)加1，而是根据类型的不同增加一个sizeof(类型)，即跳过一个数据空间，达到下一个数据空间；</p>\n<ol>\n<li>多重指针:指针本身也是一种类型，即指针能够指向指针；</li>\n</ol>\n"},{"title":"指针与数组","url":"/2022/10/18/%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/","content":"<h1 id=\"一-指针与数组\"><a href=\"#一-指针与数组\" class=\"headerlink\" title=\"一.指针与数组\"></a>一.指针与数组</h1><ol>\n<li><p>数组是一块连续的内存单元，其中数组名的值就是这块连续内存的首地址；一个指针变量既可以指向一个数组，也可以指向一个数组元素；比如：指针变量p=a与a与&amp;a[0]的值是一样的，都指向数组a的首地址，也是0号元素，a[0]的地址；p+1,a+1,&amp;a[1]都指向1号元素，类似可得p+i，a+i，&amp;a[i]指向i号元素；应注意指针是变量，数组名和数组元素是常量；</p>\n</li>\n<li><p>引入指针后可用<em>(p+i)的形式访问数组a[i]的元素，下标法：通过p[i]访问a[i]的元素；指针法：</em>(p+i)访问a[i]的元素；</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">int a[5],*p=a<br>for(int i=1;i&lt;=5;i++)&#123;<br>    scanf(&quot;%d&quot;,&amp;a[i]);//a[i]与a+i和p+i等价；<br>&#125;<br>for(int i=1;i&lt;=5;i++)&#123;<br>    printf(&quot;%d&quot;,a[i]);//a[i]与*(p+i),*(a+i),p[i]等价<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>把a当指针用，a+i指向第i个元素；注意a是静态常量，是不可变的，指针是变量，可以变化，如p=p+1是合法的，a=a+1是非法的；</p>\n<ol>\n<li>指针也可以看出数组名；</li>\n</ol>\n<p>指针是可以作为动态数组进行使用的，因为指针可以动态申请空间，且如果一次性申请多个变量空间，则系统给的空间则是连续的，这种情况下便可以当成数组进行操作；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">int *a;<br>int n;<br>scanf(&quot;%d&quot;,&amp;n);<br>a=new int[n+1]；//向系统申请连续的n+1个int型的空间；<br>//a=(int *)malloc(sizeof(int)*n)<br>for(int i=1;i&lt;=n;i++)&#123;<br>    scanf(&quot;%d&quot;,&amp;a[i]);<br>&#125;<br>for(int i=1;i&lt;=n;i++)&#123;<br>    printf(&quot;%d&quot;,a[i]);<br>&#125;<br>delete []a;//释放空间<br>//free(a);<br></code></pre></td></tr></table></figure>\n"},{"title":"指针动态数组(2)","url":"/2022/10/27/%E6%8C%87%E9%92%88%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84(2)/","content":"<h1 id=\"new函数-分配空间\"><a href=\"#new函数-分配空间\" class=\"headerlink\" title=\"new函数(分配空间)\"></a>new函数(分配空间)</h1><p>使用格式:</p>\n<pre><code> (1)指针变量名=new 类型标识符；\n (2)指针变量名=new 类型标识符(初始值)；\n (3)指针变量吗=new 类型标识符[内存单元个数]；\n</code></pre><p>对于(1)申请<strong>一个</strong>类型标识符大小的字节空间给指针变量名，对于(2)在申请<strong>一个</strong>类型标识符的同时对申请的空间进行赋予初始值，而对于(3)则是申请一个动态数组；</p>\n<p>其中分配成功则返回对象类型的指针地址，失败会抛出异常；</p>\n<h1 id=\"delete函数-对于上面的new函数\"><a href=\"#delete函数-对于上面的new函数\" class=\"headerlink\" title=\"delete函数(对于上面的new函数)\"></a>delete函数(对于上面的new函数)</h1><p>delete函数用于回收new函数分配的内存空间</p>\n<p>其中对于单个对象的内存空间的时候用<strong>delete 指针变量名</strong> 释放空间；</p>\n<p>对于用new[]分配的一组内存空间，用<strong>delete []指针变量名</strong> 释放空间；</p>\n<h1 id=\"new函数与malloc函数的一些区别\"><a href=\"#new函数与malloc函数的一些区别\" class=\"headerlink\" title=\"new函数与malloc函数的一些区别\"></a>new函数与malloc函数的一些区别</h1><ol>\n<li><p>new是从自由存储区上动态分配空间，而malloc函数则是在堆上动态分配空间；其中自由存储区是C++的一个基于new操作符的抽象概念，即通过new函数动态申请的空间内存都为自由存储区；堆是系统的术语，是系统维护的一块特殊内存，用于内存的动态分配；关于自由存储区，不仅可以是堆，也可以是静态存储区，这取决于operator new将对象分配到哪个空间<del>(ps:目前我也不懂，以后再了解学习，嘻嘻)</del>；</p>\n</li>\n<li><p>分配成功时new返回不需要进行强制类型转换，malloc返回的时void*，需要进行强制转换类型，基于这一点new函数的安全性高于malloc函数；</p>\n</li>\n<li><p>分配失败时malloc函数返回NULL，而new函数直接抛出程序异常；</p>\n</li>\n<li><p>对于申请的内存空间大小，malloc函数需要进行计算，而new函数无需指定内存空间大小，系统会根据类型信息自行计算；</p>\n</li>\n</ol>\n"},{"title":"时间复杂度与空间复杂度","url":"/2022/10/13/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","content":"<p>在数据结构和算法中，因为算法本身是不分“好坏”的，而所谓“最好”的算法，则是指最适合当前场景的算法。因此通常考虑程序的执行效率和占用的内存空间，即时间复杂度和空间复杂度，时间复杂度用来表示算法运行时间，空间复杂度用来表示算法所使用的空间。</p>\n<p>通常用O来表示复杂度；</p>\n<p>对于空间复杂度，在一个执行的程序中，占用的内存空间主要包括：</p>\n<p>1.程序代码本身所占用的存储空间；</p>\n<p>2.如果需要输入输出数据，也会占用一定的存储空间；</p>\n<p>3.运行过程中，可能还需要临时申请更多的存储空间。</p>\n<p>对于第一点，可以通过在编写代码的同时在保证功能的前提下，尽可能的编写足够短的代码；</p>\n<p>对于第二点，程序运行过程中输入输出的数据，往往由要解决的问题而定，即便所用算法不同，程序输入输出所占用的存储空间也是相近的。</p>\n<p>对于第三点，在程序运行过程中临时申请的内存空间，不同算法编写出的程序，运行时申请的临时存储空间通常会有较大不同，因此根据不同的情况编写合适的代码，可以减少空间复杂度；</p>\n<p>空间复杂度的估算方法是：</p>\n<ul>\n<li>如果算法中额外申请的内存空间不受用户输入值的影响（即一个固定值），那么该算法的空间复杂度用<code>O(1)</code>表示；</li>\n<li>如果随着输入值 n 的增大，算法申请的存储空间成线性增长，则程序的空间复杂度用<code>O(n)</code>表示;</li>\n<li>如果随着输入值 n 的增大，程序申请的存储空间成 n^2 关系增长，则程序的空间复杂度用<code>O(n^2)</code>表示；</li>\n<li>如果随着输入值 n 的增大，程序申请的存储空间成 n^3 关系增长，则程序的空间复杂度用<code>O(n^3)</code>表示；</li>\n</ul>\n<p>大多数情况下，一个好的程序更注重时间复杂度，空间复杂度在一个合理范围即可；</p>\n<p>对于时间复杂度，即预估算法的执行时间；</p>\n<p>计算一个算法的时间复杂度，需要经过以下 3 个步骤：</p>\n<h4 id=\"1-统计算法中各个步骤的执行次数\"><a href=\"#1-统计算法中各个步骤的执行次数\" class=\"headerlink\" title=\"1) 统计算法中各个步骤的执行次数\"></a>1) 统计算法中各个步骤的执行次数</h4><h4 id=\"2-简化算法的执行次数\"><a href=\"#2-简化算法的执行次数\" class=\"headerlink\" title=\"2) 简化算法的执行次数\"></a>2) 简化算法的执行次数</h4><h4 id=\"3-用大O记法表示算法的时间复杂度\"><a href=\"#3-用大O记法表示算法的时间复杂度\" class=\"headerlink\" title=\"3) 用大O记法表示算法的时间复杂度\"></a>3) 用大O记法表示算法的时间复杂度</h4><p>在简化中，以 3<em>n2+4</em>n+5 为例，简化过程为：</p>\n<ol>\n<li>当 n 无限大时，3n^2+4n 与 3<em>n^2+4</em>n+5 的值非常接近，是否加 5 对表达式的值影响不大，因此表达式可以简化为 3<em>n^2+4</em>n；</li>\n<li>当 n 无限大时，3<em>n^2 的值要远远大于 4</em>n 的值，它们之间类似于 10000 和 1 之间的关系，因此是否加 4<em>n 对表达式最终的值影响不大，整个表达式可以简化为 3</em>n^2；</li>\n<li>当 n 无限大时，n^2 的值已经超级大，是否乘 3 对最终结果影响不大，整个表达式可以简化为  n^2。</li>\n</ol>\n<p>基于“n 值无限大”的思想，3<em>n^2+4</em>n+5 最终就简化成了 n^2。</p>\n<p>一般情况下的时间复杂度之间大小有以下关系</p>\n<p>O(1)&lt; O(logn) &lt; O(n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)</p>\n<p>其中<code>O(1)</code>是最小的，对应的算法的执行时间最短，执行效率最高。</p>\n<p>最后在实际过程，往往采用 “预先估值”的方法挑选算法。具体来讲，就是分析各个算法的实现过程（步骤），估算出它们各自的运行时间和占用的内存大小，就可以挑选出“最好”的算法。</p>\n"},{"title":"指针动态数组（1）","url":"/2022/10/25/%E6%8C%87%E9%92%88%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84(1)/","content":"<h1 id=\"malloc函数\"><a href=\"#malloc函数\" class=\"headerlink\" title=\"malloc函数\"></a>malloc函数</h1><ol>\n<li><p>头文件：#include <malloc.h>；</p>\n</li>\n<li><p>使用：(void <em>)malloc(sizeof(void)</em>num);</p>\n</li>\n</ol>\n<p>其中void指示类型，sizeof是计算一个这个类型需要的字节，*num表示需要多少个这个类型的字节的空间，malloc后面的括号内也可以直接用数字填入，表示需要多少个字节的空间；</p>\n<ol>\n<li><p>成功返回分配空间的首地址，不成功则返回空指针NULL；</p>\n</li>\n<li><p>当内存不再使用时应使用free()函数将内存块释放掉；</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">#include&lt;malloc.h&gt;<br>int *a;<br>int n;<br>a=(int *)malloc(sizeof(int)*n)<br></code></pre></td></tr></table></figure>\n<h1 id=\"free函数\"><a href=\"#free函数\" class=\"headerlink\" title=\"free函数\"></a>free函数</h1><ol>\n<li><p>头文件：free函数头文件和malloc函数一致，即<malloc.h>;</p>\n</li>\n<li><p>使用：free(a);a=NULL;</p>\n</li>\n</ol>\n<p>free后要将指针指向NULL，避免成为野指针；因为free是将指针所指向的那片内存清除，但是指针所指向的地址仍然是相同的，如果不对指针进行处理，指针将会成为野指针；</p>\n<h1 id=\"calloc函数\"><a href=\"#calloc函数\" class=\"headerlink\" title=\"calloc函数\"></a>calloc函数</h1><ol>\n<li><p>头文件：#include<stdlib.h>或者#include <malloc.h>;</p>\n</li>\n<li><p>使用:(void *)calloc(num,sizeof(void));</p>\n</li>\n</ol>\n<p>calloc函数与free函数配套使用，calloc函数与malloc函数几乎相同，返回类型为空指针；</p>\n<p>num表示需要的空间类型的数量，void表示需要的类型，</p>\n<ol>\n<li>区别:malloc的使用效率更加高，因为callloc函数在申请动态空间时会将每一个字节都初始化为0；</li>\n</ol>\n<h1 id=\"realloc函数\"><a href=\"#realloc函数\" class=\"headerlink\" title=\"realloc函数\"></a>realloc函数</h1><ol>\n<li><p>头文件:#include<stdio.h>或者#include <malloc.h></p>\n</li>\n<li><p>使用:(void <em>)realloc(指针,num </em>sizeof(int)；</p>\n</li>\n<li><p>介绍:realloc是对动态内存进行扩容(即已经申请的动态空间不够使用，需要进行扩容，指针为原来的空间地址的指针，num为扩容后的大小；</p>\n</li>\n</ol>\n<p>实际上如果num比较小，即原空间后面还有空余的内存空间，并且原空间加上空闲空间等于num，则系统将直接在原内存空间后面扩容，<strong>并返回原动态空间地址</strong>；如果num比较大，原来申请的空间后面没有足够大的空间扩容，系统将重新申请一块(num<em>sizeof(void))的内存，并把原来空间的内容拷贝过去，原来空间进行free操作，因此原空间不需要进行free操作，<strong>同时返回寻找到的空间的地址</strong>;如果num非常大，系统内存申请失败，<em>*返回NULL</em></em>,原来的内存不会释放。</p>\n<p>注意：(1)如果扩容后的内存空间比原空间小，将会出现数据丢失，如果直接realloc(p, 0);相当于free(p);</p>\n<p>(2)若realloc成功，指向原内存地址的指针就成了<strong>悬挂指针</strong>，即指针指向了一块没有分配给用户使用的内存，如果再用该指针进行操作就可能发生意想不到的问题。所以在应用realloc是应当格外注意这种情况;</p>\n<p>(3)传递给realloc的[指针必须是先前通过malloc,calloc 或realloc()分配的;</p>\n<p>(4)传递的指针可以为空，等同于malloc;</p>\n<p><del>ps:还有new与delete函数，累了下次写；</del></p>\n"},{"title":"插入排序","url":"/2022/10/07/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","content":"<h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include \"></a>include <stdio.h></h1><p>int main(){<br>    int n;<br>    /<em>printf(“输入要输入的数的数量\\n”);<br>    scanf(“%d”,&amp;n);<br>    printf(“输入数字\\n”);</em>/<br>     n=4;<br>     int a[n+1];<br>      for(int i=1;i&lt;=n;i++)scanf(“%d”,&amp;a[i]);<br>     for(int i=1;i&lt;=n;i++){<br>         int j,t,k;<br>         for(j=i-1;j&gt;=1;j—){<br>             if(a[i]&gt;a[j])break;<br>             }<br>             if(j!=i-1){<br>                 t=a[i];<br>                 for(k=i-1;k&gt;j;k—)a[k+1]=a[k];<br>                 a[k+1]=t;<br>             }<br>     }<br>    for(int i=1;i&lt;=n;i++){<br>         printf(“%d “,a[i]);<br>     }<br>     return 0;<br>} </p>\n"},{"title":"看板娘","url":"/2022/10/01/%E7%9C%8B%E6%9D%BF%E5%A8%98/","content":"<h2 id=\"一、安装hexo-helper-live2d-插件\"><a href=\"#一、安装hexo-helper-live2d-插件\" class=\"headerlink\" title=\"一、安装hexo-helper-live2d 插件\"></a>一、安装hexo-helper-live2d 插件</h2><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">npm install --save hexo-helper-live2d<br></code></pre></td></tr></table></figure>\n<h2 id=\"二、下载live2d模型\"><a href=\"#二、下载live2d模型\" class=\"headerlink\" title=\"二、下载live2d模型\"></a>二、下载live2d模型</h2><p>下面给出看板娘模型的名单和预览图，你可以挑一个想要的</p>\n<p>预览图：<a href=\"https://link.zhihu.com/?target=https%3A//huaji8.top/post/live2d-plugin-2.0/\">https://huaji8.top/post/live2d-plugin-2.0/</a></p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">live2d-widget-model-chitose<br>live2d-widget-model-epsilon2_1<br>live2d-widget-model-gf<br>live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)<br>live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)<br>live2d-widget-model-haruto<br>live2d-widget-model-hibiki<br>live2d-widget-model-hijiki<br>live2d-widget-model-izumi<br>live2d-widget-model-koharu<br>live2d-widget-model-miku<br>live2d-widget-model-ni-j<br>live2d-widget-model-nico<br>live2d-widget-model-nietzsche<br>live2d-widget-model-nipsilon<br>live2d-widget-model-nito<br>live2d-widget-model-shizuku<br>live2d-widget-model-tororo<br>live2d-widget-model-tsumiki<br>live2d-widget-model-unitychan<br>live2d-widget-model-wanko<br>live2d-widget-model-z16<br></code></pre></td></tr></table></figure>\n<p>然后执行指令↓</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">npm install live2d-widget-model-koharu //假设你选择的看板娘是koharu<br></code></pre></td></tr></table></figure>\n<h2 id=\"三、修改-config-yml配置文件\"><a href=\"#三、修改-config-yml配置文件\" class=\"headerlink\" title=\"三、修改_config.yml配置文件\"></a>三、修改_config.yml配置文件</h2><p>找到你博客的本地存储的根目录，打开_config.yml文件，添加下面的内容</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">#Live2D动画<br>live2d:<br>  enable: true<br>  scriptFrom: local<br>  pluginRootPath: live2dw/<br>  pluginJsPath: lib/<br>  pluginModelPath: assets/<br>  tagMode: false<br>  debug: false<br>  model:<br>    use: live2d-widget-model-koharu <br>  display:<br>    position: right <br>    width: 150<br>    height: 300<br>  mobile:<br>    show: true<br></code></pre></td></tr></table></figure>\n<h2 id=\"四、主要参数说明\"><a href=\"#四、主要参数说明\" class=\"headerlink\" title=\"四、主要参数说明\"></a>四、主要参数说明</h2><ol>\n<li>enable //是否使用</li>\n<li>model:<br>use: live2d-widget-model-koharu //要使用的模型名称</li>\n<li>display:<br>position: right //显示的位置<br>width: 150 //宽度<br>height: 150 //高度<br>mobile:<br>show: true //移动端是否显示</li>\n</ol>\n<h2 id=\"五、调试-amp-部署\"><a href=\"#五、调试-amp-部署\" class=\"headerlink\" title=\"五、调试&amp;部署\"></a>五、调试&amp;部署</h2><p>在你已经安装git环境的基础上，在博客的本地存储根目录下右键-&gt;Git Bash Here</p>\n<p>依次输入↓</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">hexo clean<br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure>\n<p>现在你就可以在本地预览一下自己的博客精灵啦，打开浏览器登录：<strong>localhost:4000</strong></p>\n<p>或者，<a href=\"https://link.zhihu.com/?target=http%3A//localhost%3A4000/\">点击这里</a>~</p>\n<p>相中好看板娘之后，就可以部署到GitHub pages上了</p>\n<p>回到git，输入下面的指令并成功登录后…</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><code class=\"hljs text\">hexo d<br></code></pre></td></tr></table></figure>\n"},{"title":"文件函数","url":"/2022/12/03/%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0/","content":"<h3 id=\"一-fopen-函数\"><a href=\"#一-fopen-函数\" class=\"headerlink\" title=\"一.fopen()函数\"></a>一.fopen()函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs 系统打开文件时定义的结构体\">typedef struct<br>&#123; int fd; //文件号<br> int cleft; //缓冲区中剩下的字符数<br> int _ode; //文件操作方式<br> char *next; //文件当前读写位置<br> char *buff; //文件缓冲区位置<br>&#125;FILE;<br></code></pre></td></tr></table></figure>\n<p>使用：<strong>FILE  <em>fp=fopen(“char  </em>name”, “char *mode”);</strong></p>\n<p><strong>name</strong> 表示文件的文件名(可以包含路径)，<strong>*mode</strong> 表示打开的方式；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mode打开方式\">r：以只读方式打开文件，该文件必须存在;<br>r+：以读/写方式打开文件，该文件必须存在;<br>rb+：以读/写方式打开一个二进制文件，只允许读/写数据;<br>rt+：以读/写方式打开一个文本文件，允许读和写;<br>w：打开只写文件，若文件存在则文件长度清为零(相当与删除原文件，重新建立一个同名新文件)；<br>若文件不存在则创建该文件;<br>w+：打开可读/写文件，(类似w和r+的结合)若文件存在则文件长度清为零，即该文件内容会消失；<br>若文件不存在则创建该文件；<br>a：以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会<br>被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）；<br>a+：以附加方式打开可读/写的文件。(相当于a和r+的结合)若文件不存在，则会创建该文件，<br>如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）；<br>wb：以只写方式打开或新建一个二进制文件，只允许写数据;<br>wb+：以读/写方式打开或新建一个二进制文件，允许读和写;<br>wt+：以读/写方式打开或新建一个文本文件，允许读和写;<br>at+：以读/写方式打开一个文本文件，允许读或在文本末追加数据;<br>ab+：以读/写方式打开一个二进制文件，允许读或在文件末追加数据。<br>(打开方式不表明是t或者b时，默认为t)<br></code></pre></td></tr></table></figure>\n<p>fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，当文件打开失败时返回一个空指针(NULL)，成功则返回该结构体地址；在打开文件时一定要判断文件是否打开成功，因为一旦打开失败，后续操作就都没法进行了，往往以“结束程序”告终。</p>\n<p>文件使用完毕要关闭函数:</p>\n<p><strong>int fclose(FILE *fp)</strong> 正常关闭时返回0，返回非0时表示出错；</p>\n<p><strong>fp=NULL</strong> 指针需要指向空地址，否则依然指向文件的地址；</p>\n<h3 id=\"二-feof-函数\"><a href=\"#二-feof-函数\" class=\"headerlink\" title=\"二. feof()函数\"></a>二. feof()函数</h3><p>feof()一般用来判断一个文件是否结束，如果文件结束，则返回非0值，否则返回0；</p>\n<p>对于这个函数有一个经典错误，那就是关于EOF；</p>\n<p>EOF是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取，资料源通常称为档案或串流，通常在文本的最后存在此字符表示资料结束。</p>\n<p>即在文件的结尾包含EOF这个内容，其值通常为-1，在不同的系统值可能有所不同；</p>\n<p>对于feof()来说，并不是通过读到EOF来判断文件是否为空，而是读取文件中输入光标后面是否有内容来判断文件是否为空，而一个文件即使没有输入数据，文件中也有EOF作为内容表示文件资料结束，因此feof()使用时站在光标后面观察是否有数据时看见了EOF自然就判断文件不为空；</p>\n<p>getc(FILE *name)，通过这个函数从文件中读取一个内容字符，让光标后移一个字符，让光标移动到EOF后面，这个时候在判断文件是否为空；</p>\n<p>注意使用这个函数后要在使用 <strong>rewind(FILE*name)</strong> 函数使光标回到文件开头部位，这样才能保住文件的正常使用；</p>\n<h3 id=\"三-格式化读写函数\"><a href=\"#三-格式化读写函数\" class=\"headerlink\" title=\"三.格式化读写函数\"></a>三.格式化读写函数</h3><p>格式化读取函数：<strong>fprintf()</strong> </p>\n<p>使用：<strong>fprintf(FILE <em>fp,char </em>format,····)</strong>，format表示格式控制输入字符串，····表示参数列表；</p>\n<p>格式化写入函数：<strong>fscanf()</strong> </p>\n<p>使用：<strong>fscanf(FILE <em>fp,,char </em>format,····)</strong>,意义同上；</p>\n<p>fprintf()使用成功时返回成功写入的字符个数，失败返回负数；</p>\n<p>fscanf()使用时返回参数列表中被成功赋值的参数个数；</p>\n<p>如果将 fp 设置为 stdin，那么 fscanf() 函数将会从键盘读取数据，与 scanf 的作用相同；设置为 stdout，那么 fprintf() 函数将会向显示器输出内容，与 printf 的作用相同。</p>\n<h3 id=\"四-字符读写函数\"><a href=\"#四-字符读写函数\" class=\"headerlink\" title=\"四.字符读写函数\"></a>四.字符读写函数</h3><p>字符读取函数：<strong>fgetc()</strong>;</p>\n<p>fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符；</p>\n<p>使用：<strong>fgetc(FILE *fp)</strong>,</p>\n<p>成功时返回读取到的字符；</p>\n<p>注意：在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。  </p>\n<p>字符写入函数：<strong>fputc()</strong>;</p>\n<p>fputc 是 file output char 的缩写，意思是向指定的文件中写入一个字符；</p>\n<p>使用：<strong>fputc(char c,FILE *fp)</strong>,</p>\n<p>fputc() 写入成功时返回写入的字符，失败时返回 EOF;</p>\n<h6 id=\"两点说明\"><a href=\"#两点说明\" class=\"headerlink\" title=\"两点说明:\"></a>两点说明:</h6><p>1) 被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。  </p>\n<p>2) 每写入一个字符，文件内部位置指针向后移动一个字节。</p>\n<h3 id=\"五-数据块读写函数\"><a href=\"#五-数据块读写函数\" class=\"headerlink\" title=\"五.数据块读写函数\"></a>五.数据块读写函数</h3><p>C语言提供了用于整块数据的读写函数。可用来读一组数据，如一个数组元素，一个结构变量的值等；</p>\n<p>数据块读取函数：<strong>fread(void <em> p,size</em>number,count,FILE *fp)</strong> ;</p>\n<p>数据块写入函数：<strong>fwrite(void <em> p,size</em>number,count,FILE *fp)</strong></p>\n<p>指针p表示存放输出数据/存放输入数据的首地址，size*number表示数据块字节数，count表示读取/输入的数据块块数，fp表示文件指针；函数返回读取到/写入的元素个数；</p>\n<p>此函数一般用于二进制文件的输入和输出；</p>\n<h3 id=\"六-字符串读写函数\"><a href=\"#六-字符串读写函数\" class=\"headerlink\" title=\"六.字符串读写函数\"></a>六.字符串读写函数</h3><p>字符串写入函数:<strong>fputs(const char <em>s, FILE </em>fp)</strong></p>\n<p>其中，s是要写入的字符串，fp是文件指针；将字符串s输入至fp所指向的文件（不含’\\0’）。如果成功，位置指针自动后移，函数返回最后写入的一个字符；否则返回EOF。</p>\n<p>字符串读取函数;<strong>fgets(char <em>s， int n， FILE </em>fp)</strong></p>\n<p>其中，s指向待赋值字符串的首地址，n是控制读取个数的参数，fp为文件指针；</p>\n<p>从位置指针开始读取 一行或n-1个字符，并存入s，存储时自动在字符串结尾加上’\\0’。如果函数执行成功，位置指针自动后移，并返回字符串s的首地址，否则返回NULL。</p>\n"}]