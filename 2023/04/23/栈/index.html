<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>栈 | Hexo</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":""}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/demo/"><span class="navItemTitle">独立页面</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-title"><h1>栈</h1></div><hr><div id="post-content"><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><strong>栈</strong>：限定仅在表尾进行插入或者删除操作的线性表，表尾端称为<strong>栈顶(top)</strong>，表头端称为<strong>栈底(bottom)</strong>，不含任何元素的空表称为<strong>空栈</strong>；</p>
<p>存入栈的元素之间没有任何具体的关系，只有到来的时间的先后顺序；</p>
<p>栈的修改是按后进先出的原则，因此线性表栈又称<strong>LIFO</strong>结构；</p>
<p>入栈和出栈的时间复杂度都为O(1)；</p>
<p>栈的本质是一个线性表，线性表有两种存储形式，那么栈也有分为栈的<strong>顺序存储结构</strong>和栈的<strong>链式存储结构</strong>；</p>
<p>栈的基本操作：</p>
<ul>
<li><p>栈的初始化(InitStack)</p>
</li>
<li><p>栈的销毁(DestroyStack)</p>
</li>
<li><p>栈的清空(ClearStack)</p>
</li>
<li><p>栈的判空(StcakEmpty)</p>
</li>
<li><p>栈的长度(StackLength)</p>
</li>
<li><p>获得栈顶元素(GetTop)</p>
</li>
<li><p>插入新元素(Push)</p>
</li>
<li><p>删除栈顶元素(Pop)</p>
</li>
<li><p>对栈的调用(StackTraverse)</p>
</li>
</ul>
<p>插入元素称为<strong>入栈/压栈</strong>，删除栈顶元素称为<strong>出栈</strong>；</p>
<h4 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h4><p>顺序栈是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时设指针top指向栈顶位置；</p>
<p>顺序栈利用<strong>数组</strong>实现，并默认栈的长度为StackSize，栈顶位置top必须小于StackSize，下标为 0 的一端作为栈底，并使用 top 做为栈顶，它来指示当前栈顶元素的位置，默认 top = -1 时为空栈（C语言默认数组下标从0开始）；</p>
<ul>
<li>栈的顺序存储表示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define length 100 //定义栈的长度<br>#define more 100<br>typedf 类型 ElemType; //根据现实需要，定义或修改ElemType的类型<br>typedf struct&#123;//数组<br>    ElemType date[length]; //存放栈的元素<br>    int top;//栈顶指针<br>&#125;SqStack;<br><br>typedf struct&#123;//链栈结构<br>    SelemType *base;<br>    SelemType *top;<br>    int stacksize; <br>&#125;SqStack；<br></code></pre></td></tr></table></figure>
<ul>
<li>构造一个空栈</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Status InitStack(SqStack &amp;s)&#123;<br>    s.base=(SElemType *)malloc(length*sizeof(SElemType);<br>    if(!s.base) exit(OVERFLOW) //分配失败<br>    s.top=s.base; //栈顶和栈底指向同一个地址，栈顶指向顶部元素的下一个地址<br>    //s.top=-1;栈顶指向顶部元素<br>    s.stacksize=length;<br>    return ok;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>判断栈空</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">bool StackEmpty(SqStack s)&#123;<br>    if(s.top==-1)return 1;//也可以用s.top==s.base，使用哪个看构<br>                            造时用决定的判断栈空的条件<br>    else return 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>入栈</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Status Push(SqStack &amp;s,SElemType e)&#123;<br>    if(s.top-s.base&gt;=s.stacksize)&#123;<br>    realloc(s.base,(s.stacksize+more)*sizeof(SElemType));//重新分配内存空间<br>    if(!s.base) exit(OVERFLOW); // 存储分配失败<br>       S.top = S.base+S.stacksize;  <br>       S.stacksize += more; <br>    &#125;<br>    *S.top++ = e;  <br>    return OK;<br>&#125;<br>//或者数组入栈<br>Status Push(Sqstack *s)&#123;<br>    if(s-&gt;top==s.stacksize-1) return 0;<br>    s-&gt;top++;<br>    s-&gt;date[s-&gt;top]=e;<br>    return 1;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Status Pop(SqStack &amp;s,SElemType &amp;e)&#123;<br>    if(s.top==s.base) return 0;<br>    e=*s.top-1;<br>&#125;<br>//数组<br>Status Pop(SqStack*s,ElemType *e)&#123;<br>    if(s-&gt;top==-1)return 0;<br>    *e=s-&gt;date[s-&gt;top];<br>    s-&gt;top--;<br>    return 1;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>获取栈顶元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Status GetTop(SqStack s,SElemTpe &amp;e)&#123;<br>    if(s.top==s.base) return 0;<br>    e=*(s.top-1);<br>    return 1;<br>&#125;<br>//数组<br>Status GetTop(SqStack s,ElemType *e)&#123;<br>    if(s-&gt;top==-1) return 0;<br>    *e=s-&gt;date[s-&gt;top];<br>     return 1;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>利用栈底位置相对不变的特征，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸；</p>
<p>两个栈的栈顶指针都指向栈顶元素，top0(左边栈)=-1时0号栈为空，top1(右边栈)=MaxSize时1号栈为空；仅当两个栈顶指针相邻（top0+1=top1）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减一再赋值出栈时则刚好相反；</p>
<ul>
<li>入栈和出栈</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/两栈共享空间结构*/<br>#define MAXSIZE 50  //定义栈中元素的最大个数<br>typedef int ElemType;   //ElemType的类型根据实际情况而定，这里假定为int<br>typedef struct&#123;<br>    ElemType data[MAXSIZE];<br>    int top0;    //栈0栈顶指针<br>    int top1;    //栈1栈顶指针<br>&#125;SqDouble<br>/*插入元素e为新的栈顶元素*/<br>Status Push(SqDoubleStack *S, Elemtype e, int stackNumber)&#123;<br>    if(S-&gt;top0+1 == S-&gt;top1)&#123;   //栈满<br>        return 0;<br>    &#125;<br>    if(stackNumber == 0)&#123;   //栈0有元素进栈<br>        S-&gt;data[++S-&gt;top0] = e; //若栈0则先top0+1后给数组元素赋值<br>    &#125;<br>    else if(satckNumber == 1)&#123; //栈1有元素进栈<br>        S-&gt;data[--S-&gt;top1] = e; //若栈1则先top1-1后给数组元素赋值<br>    &#125;<br>    return 1;<br>/*若栈不空，则删除S的栈顶元素，用e返回其值*/<br>Status Pop(SqDoubleStack *S, ElemType *e, int stackNumber)&#123;<br>    if(stackNumber == 0)&#123;<br>        if(S-&gt;top0 == -1)&#123;<br>            return 0;   //说明栈0已经是空栈，溢出<br>        &#125;<br>        *e = S-&gt;data[S-&gt;top0--<br>      ]; //将栈0的栈顶元素出栈，随后栈顶指针减1<br>    &#125;else if(stackNumber == 1)&#123;<br>        if(S-&gt;top1 == MAXSIZE)&#123;<br>            return 0;   //说明栈1是空栈，溢出<br>        &#125;<br>        *e = S-&gt;data[S-&gt;top1++];    //将栈1的栈顶元素出栈，随后栈顶指针加1<br>    &#125;<br>    return 1;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况；</p>
<p>基本操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*  构造一个空栈S */<br>Status InitStack(LinkStack *S)<br>&#123; <br>        S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));<br>        if(!S-&gt;top)<br>                return ERROR;<br>        S-&gt;top=NULL;<br>        S-&gt;count=0;<br>        return OK;<br>&#125;<br><br>/* 把S置为空栈 */<br>Status ClearStack(LinkStack *S)<br>&#123; <br>        LinkStackPtr p,q;<br>        p=S-&gt;top;<br>        while(p)<br>        &#123;  <br>                q=p;<br>                p=p-&gt;next;<br>                free(q);<br>        &#125; <br>        S-&gt;count=0;<br>        return OK;<br>&#125;<br><br>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */<br>Status StackEmpty(LinkStack S)<br>&#123; <br>        if (S.count==0)<br>                return TRUE;<br>        else<br>                return FALSE;<br>&#125;<br><br>/* 返回S的元素个数，即栈的长度 */<br>int StackLength(LinkStack S)<br>&#123; <br>        return S.count;<br>&#125;<br><br>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */<br>Status GetTop(LinkStack S,SElemType *e)<br>&#123;<br>        if (S.top==NULL)<br>                return ERROR;<br>        else<br>                *e=S.top-&gt;data;<br>        return OK;<br>&#125;<br><br>/* 插入元素e为新的栈顶元素 */<br>Status Push(LinkStack *S,SElemType e)<br>&#123;<br>        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode)); <br>        s-&gt;data=e; <br>        s-&gt;next=S-&gt;top; /* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */<br>        S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */<br>        S-&gt;count++;<br>        return OK;<br>&#125;<br><br>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */<br>Status Pop(LinkStack *S,SElemType *e)<br>&#123; <br>        LinkStackPtr p;<br>        if(StackEmpty(*S))<br>                return ERROR;<br>        *e=S-&gt;top-&gt;data;<br>        p=S-&gt;top;                   /* 将栈顶结点赋值给p，见图中③ */<br>        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */<br>        free(p);                    /* 释放结点p */        <br>        S-&gt;count--;<br>        return OK;<br>&#125;<br>/* 从栈底到栈顶依次对栈中每个元素显示 */<br>Status StackTraverse(LinkStack S)<br>&#123;<br>        LinkStackPtr p;<br>        p=S.top;<br>        while(p)<br>        &#123;<br>                 visit(p-&gt;data);<br>                 p=p-&gt;next;<br>        &#125;<br>        printf(&quot;\n&quot;);<br>        return OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"></div><div id="Valine"></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/3226021048XTC">Dr.落叶潇潇</a></h1><div id="description"><p>感</p><p>染</p><p>者</p><p>应</p><p>该</p><p>为</p><p>自</p><p>己</p><p>的</p><p>身</p><p>份</p><p>而</p><p>骄</p><p>傲</p><p>，</p><p>并</p><p>用</p><p>最</p><p>简</p><p>单</p><p>的</p><p>手</p><p>段</p><p>夺</p><p>取</p><p>大</p><p>地</p><p>的</p><p>公</p><p>正</p></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">栈的存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">1.0.1.</span> <span class="toc-text">共享栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-number">1.0.2.</span> <span class="toc-text">链栈</span></a></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">罗德岛：R111</a></nobr><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'LSe7mf1XYliLqgIrc3jlqXfT-gzGzoHsz'
 , appKey: 'Fu9giJfnidkCamaW89FUpidw' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"left","width":300,"height":600,"hOffset":-15,"vOffset":-15},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>