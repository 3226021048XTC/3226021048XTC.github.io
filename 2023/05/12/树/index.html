<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>树 | Hexo</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":""}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/demo/"><span class="navItemTitle">独立页面</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-title"><h1>树</h1></div><hr><div id="post-content"><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是n个结点的有限集，n=0时，称为空树；</p>
<p>当n=1时,有且仅有一个特定的称为根(Root)的结点;</p>
<p>当n&gt;1时,其余结点可以分为m(m&gt;0)个互不相交的树,称为根的子树(Sub Tree);</p>
<pre><code>         第1层               A  
高       第2层          B    C     D
度       第3层        E   F  G   H I J
为       第4层      K   L        M
4
</code></pre><ul>
<li><p>从A到K的唯一路径上的任意结点都称为K的<strong>祖先</strong>,最接近K的点E称为<strong>双亲</strong>,而K是E的<strong>孩子</strong>,有相同双亲的结点称为<strong>兄弟</strong>,如K和L;</p>
</li>
<li><p>树中一个结点的孩子数称为结点的<strong>度</strong>,树中结点的最大度数称为<strong>树的度</strong>;</p>
</li>
<li><p>度为0的结点称为<strong>叶子节点(终端结点)</strong>,度大于0的结点称为<strong>分子结点(非终端结点)</strong>;</p>
</li>
<li><p>结点的层次从树根开始,双亲结点在同一层的结点互为堂兄弟,如G,E,F,H,I,J;</p>
</li>
<li><p>结点的深度从根节点开始向下逐层累加;</p>
</li>
<li><p>结点的高度从叶子结点向上逐层累加;</p>
</li>
<li><p>树的高度(深度)是树中结点的最大层数;</p>
</li>
<li><p>如果各子树之间左右次序不能互换,则该树称为<strong>有序树</strong>,否则称为<strong>无序树</strong>;</p>
</li>
<li><p>树中两个结点之间的<strong>路径</strong>是由这两个结点之间所经过的结点序列构成的,而<strong>路径长度</strong>是路径上所经过的边的个数;</p>
</li>
<li><p><strong>森林</strong>是m (m≥0)棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树;</p>
</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树( 即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒;</p>
<p>斜树:所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树;</p>
<p>满二叉树:一棵高度为h，且含有2^h-1个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点,满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为2,一个结点的编号若为i,则双亲为i/2,左孩子为2i,右孩子为2i+1;<br>完全二叉树:高度为h,有n个结点的二叉树,当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树，当i&lt;n/2时,i为分支节点,否则为叶子结点,叶子结点只会在层次最大的两层上出现,最大层次的叶子结点依次排列在该层的最左边的位置,若结点的度为1,则该结点只有左孩子;<br>平衡二叉树:任一结点的左子树和右子树的深度差不超过1;</p>
<ul>
<li><p>二叉树中若结点为n,则边的数量为n-1;</p>
</li>
<li><p>非空二叉树第k层最多2^(k-1)个结点;</p>
</li>
<li><p>高度为h的二叉树最多右2^h-1个结点;</p>
</li>
<li><p>n个结点的完全二叉树的高度为log2 ​n+1;</p>
</li>
</ul>
<p><strong>二叉树的存储结构:</strong></p>
<p>顺序存储:用一组地址连续的存储单元依次自上而下,自左而右存储完全二叉树上的结点元素,即将完全二叉树上编号为i的结点元素存储在一维数组中下标为i-1的分量中;</p>
<p>依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系;</p>
<p>对于一般二叉树,为了保持结点间的关系,需要添加一些空元素占据存储空间,最坏情况下，一个高度为h,且只有h个结点的单支树却需要占据近2^h-1个存储单元;</p>
<p>链式存储结构:二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成,则一个结点指示包含数据域,左,右指针域,有时为了便于找到双亲结点,还可以添加一个指向双亲结点的指针域;</p>
<p><strong>二叉树的遍历</strong>:</p>
<p>从根节点出发,访问二叉树中所有结点,每个结点仅被访问一次;</p>
<p>先序遍历:访问根节点,遍历左子树,遍历右子树;</p>
<p>中序遍历:遍历左子树,访问根节点,遍历右子树;</p>
<p>后序遍历:遍历左子树,遍历右子树,访问根节点;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void PreOrder(BiTree T)&#123;  //先序遍历<br>    if(T != NULL)&#123;<br>        visit(T);    //访问根节点<br>        PreOrder(T-&gt;lchild);    //递归遍历左子树<br>        PreOrder(T-&gt;rchild);    //递归遍历右子树<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void InOrder(BiTree T)&#123;//中序遍历<br>    if(T != NULL)&#123;<br>        InOrder(T-&gt;lchild);    //递归遍历左子树<br>        visit(T);    //访问根结点<br>        InOrder(T-&gt;rchild);    //递归遍历右子树<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void InOrder(BiTree T)&#123;//后序遍历<br>    if(T != NULL)&#123;<br>        InOrder(T-&gt;lchild);    //递归遍历左子树<br>        InOrder(T-&gt;rchild);    //递归遍历右子树<br>        visit(T);    //访问根结点<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>中序遍历的非递归算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void InOrder2(BiTree T)&#123;<br>    InitStack(S);    //初始化栈S<br>    BiTree p = T;    //p是遍历指针<br>    while(p || !IsEmpty(S))&#123;    //栈不空或p不空时循环<br>        if(p)&#123;<br>            Push(S, p);    //当前节点入栈<br>            p = p-&gt;lchild;    //左孩子不空，一直向左走<br>        &#125;else&#123;<br>            Pop(S, p);    //栈顶元素出栈<br>            visit(p);    //访问出栈结点<br>            p = p-&gt;rchild;    //向右子树走，p赋值为当前结点的右孩子<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先序遍历的非递归算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void PreOrder2(BiTree T)&#123;<br>    InitStack(S);    //初始化栈S<br>    BiTree p = T;    //p是遍历指针<br>    while(p || !IsEmpty(S))&#123;    //栈不空或p不空时循环<br>        if(p)&#123;<br>            visit(p);    //访问出栈结点<br>            Push(S, p);    //当前节点入栈<br>            p = p-&gt;lchild;    //左孩子不空，一直向左走<br>        &#125;else&#123;<br>            Pop(S, p);    //栈顶元素出栈<br>            p = p-&gt;rchild;    //向右子树走，p赋值为当前结点的右孩子<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>后序遍历的非递归算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void PostOrder2(BiTree T)&#123;<br>    InitStack(S);<br>    BiTree p = T;<br>    r = NULL;<br>    while(p || !IsEmpty(S))&#123;<br>        if(p)&#123;    //走到最左边<br>            push(S, p);<br>            p = p-&gt;lchild;<br>        &#125;else&#123;    //向右<br>            GetTop(S, p);    //读栈顶元素（非出栈）<br>            //若右子树存在，且未被访问过<br>            if(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)&#123;<br>                p = p-&gt;rchild;    //转向右<br>                push(S, p);    //压入栈<br>                p = p-&gt;lchild;    //再走到最左<br>            &#125;else&#123;    //否则，弹出结点并访问<br>                pop(S, p);    //将结点弹出<br>                visit(p-&gt;data);    //访问该结点<br>                r = p;    //记录最近访问过的结点<br>                p = NULL;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>线索二叉树</strong></p>
<p>遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点(第一个和最后一个结点除外)都有一个直接前驱和直接后继,传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继;</p>
<p>把利用空指针存放指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct ThreadNode&#123;<br>    ElemType data;    //数据元素<br>    struct ThreadNode *lchild, *rchild;    //左、右孩子指针<br>    int ltag, rtag;    //左、右线索标志 0表示指向该结点的左右孩子，<br>                       //1表示指向该结点的前驱或后继<br>&#125;ThreadNode, *ThreadTree;<br></code></pre></td></tr></table></figure>
<p>二叉树的线索化：</p>
<p>二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树，线索化的过程就是在遍历的过程中修改空指针的过程;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void InThread(ThreadTree p, ThreadTree pre)&#123;//中序遍历二叉树线索化递归<br>    if(p != NULL)&#123;<br>        InThread(p-&gt;lchild, pre);    //递归，线索化左子树<br>        if(p-&gt;lchild == NULL)&#123;    //左子树为空，建立前驱线索<br>            p-&gt;lchild = pre;<br>            p-&gt;ltag = 1;<br>        &#125;<br>        if(pre != NULL &amp;&amp; pre-&gt;rchild == NULL)&#123;<br>            pre-&gt;rchild = p;    //建立前驱结点的后继线索<br>            pre-&gt;rtag = 1;<br>        &#125;<br>        pre = p;    //标记当前结点成为刚刚访问过的结点<br>        InThread(p-&gt;rchild, pre);    //递归，线索化右子树<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在二叉树的线索链表上添加一个头结点，左孩子指向根结点，右孩子指向最后一个结点；第一个叶子结点的左孩子指向头结点，最后一个叶子结点的右孩子指向头结点；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍<br>的最后一个结点。中序遍历二叉线索链表表示的二叉树T*/<br>void InOrderTraverse_Thr(BiThrTree T)&#123;<br>    BiThrTree p;<br>    p = T-&gt;lchild;    //p指向根结点<br>    //空树或遍历结束时，p==T（最后一个结点指向根结点）<br>    while(p != T)&#123;    <br>        //当ltag==0时循环到中序序列第一个结点<br>        while(p-&gt;ltag == 0)&#123;    <br>            p = p-&gt;lchild;    //p指向p的左子树<br>        &#125;<br>        visit(p);    //访问该结点<br>        //后继线索为1且不是指向头指针<br>        while(p-&gt;rtag == 1 &amp;&amp; p-&gt;rchild != T)&#123;    <br>            p = p-&gt;rchild;    //p指向p的后继<br>            visit(p);    //访问该节点<br>        &#125;<br>        //p进至其右子树根，开始对右子树根进行遍历<br>        p = p-&gt;rchild;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h3><p>集合（等价问题）：</p>
<p>采用数组存储形式，parent域负数表示根节点，非负数表示双亲结点下标；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct &#123;<br>    ElementType Data;<br>    int Parent;<br>&#125; SetType;<br></code></pre></td></tr></table></figure>
<p>集合的查找运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int Find(SetType S[], ElementType X)<br>&#123;   //在数组S中查找值为X的元素所属的集合<br>    //Maxsize是全局变量，为数组S的最大长度<br>    int i;<br>    for (i=0 ; i &lt; Maxsize &amp;&amp; S[i].Data != X; i++);  <br>                                 //当S[i].Data = X时，循环结束，i为X的位置下标<br>    if(i &gt;= Maxsize)  return -1;  //未找到X，返回-1 <br>    for (; S[i].Parent &gt;= 0; i = S[i].Parent); <br>     //如果i &lt; Maxsize,寻找父结点，直到S[i].Parent &lt; 0为止（根结点的Parent为-1）<br>    return i;  //找到X所属集合，返回树根结点在数组S中的下标<br>&#125;<br></code></pre></td></tr></table></figure>
<p>集合的并运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void Union(SetType S[ ], ElementType X1, ElementType X2)<br>&#123;<br>    int Root1, Root2;<br>    Root1 = Find(S, X1);<br>    Root2 = ind(S, X2);<br>    if (Root1 != Root2)  //当x1和x2不属于同一子集时，才需要合并<br>       S[Root2].Parent = Root1;  <br>&#125;<br>//采用小集合合并到大集合中<br>void Union(SetType S, SetName Root1, SetName Root2)<br>&#123;   //这里默认Root1和Root2是不同集合的根结点<br>    //保证小集合并入大集合<br>    if ( S[Root2] &lt; S[Root1] ) &#123;  //如果集合2比较大<br>        S[Root2] += S[Root1];     //集合1并入集合2<br>        S[Root1].Parent= Root2;<br>    &#125;<br>    else &#123;                         //如果集合1比较大<br>        S[Root1] += S[Root2];     //集合2并入集合1<br>        S[Root2].Parent= Root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>二叉排序树</strong>：</p>
<p>定义：非空左子树的值小于根结点，非空右子树的值大于根结点，左右子树分别是一颗二叉排序树；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*二叉树的二叉链表结点结构定义*/<br>typedef struct BiTNode<br>&#123;<br>    int data;    //结点数据<br>    struct BiTNode *lchild, *rchild;    //左右孩子指针<br>&#125; BiTNode, *BiTree;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*<br>递归查找二叉排序树T中是否存在key<br>指针f指向T的双亲，其初始调用值为NULL<br>若查找成功，则指针p指向该数据元素结点，并返回TRUE<br>否则指针p指向查找路径上访问的最后一个结点并返回FALSE<br>*/<br>bool SearchBST(BiTree T, int key, BiTree f, BiTree *p)&#123;<br>    if(!T)&#123;<br>        *p = f;<br>        return FALSE;<br>    &#125;else if(key == T-&gt;data)&#123;<br>        //查找成功<br>        *p = T;<br>        return TRUE;<br>    &#125;else if(key &lt; T-&gt;data)&#123;<br>        return SearchBST(T-&gt;lchild, key, T, p);    //在左子树继续查找<br>    &#125;else&#123;<br>        return SearchBST(T-&gt;rchild, key, T, p);    //在右子树继续查找<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*<br>当二叉排序树T中不存在关键字等于key的数据元素时<br>插入key并返回TRUE，否则返回FALSE<br>*/<br>bool InsertBST(BiTree *T, int key)&#123;<br>    BiTree p, s;<br>    if(!SearchBST(*T, key, NULL, &amp;p))&#123;<br>        //查找不成功<br>        s = (BiTree)malloc(sizeof(BiTNode));<br>        s-&gt;data = key;<br>        s-&gt;lchild = s-&gt;rchild = NULL;<br>        if(!p)&#123;<br>            *T = s;    //插入s为新的根节点<br>        &#125;else if(key &lt; p-&gt;data)&#123;<br>            p-&gt;lchild = s;    //插入s为左孩子<br>        &#125;else&#123;<br>            p-&gt;rchild = s;    //插入s为右孩子<br>        &#125;<br>        return TRUE;<br>        &#125;else&#123;<br>            return FALSE;    //树种已有关键字相同的结点，不再插入<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*<br>若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点，<br>并返回TRUE;否则返回FALSE<br>*/<br>bool DeleteBST(BiTree *T, int key)&#123;<br>    if(!*T)&#123;<br>        return FALSE; <br>    &#125;else&#123;<br>        if(key == (*T)-&gt;data)&#123;<br>            //找到关键字等于key的数据元素<br>            return Delete(T);<br>        &#125;else if(key &lt; (*T) -&gt; data)&#123;<br>            return DeleteBST((*T) -&gt; lchild, key);<br>        &#125;else&#123;<br>            return DeleteBST((*T) -&gt; rchild, key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*从二叉排序树中删除结点p，并重接它的左或右子树。*/<br>bool Delete(BiTree *p)&#123;<br>    BiTree q, s;<br>    if(p-&gt;rchild == NULL)&#123;<br>        //右子树为空则只需重接它的左子树<br>        q = *p;<br>        *p = (*p)-&gt;lchild;<br>        free(q);<br>    &#125;else if((*p)-&gt;lchild == NULL)&#123;<br>        //左子树为空则只需重接它的右子树<br>        q = *p;<br>        *p = (*p)-&gt;rchild;<br>        free(q);<br>    &#125;else&#123;<br>        //左右子树均不空<br>        q = *p;<br>        s = (*p)-&gt;lchild;    //先转左<br>        while(s-&gt;rchild)&#123;//然后向右到尽头，找待删结点的前驱<br>            q = s;<br>            s = s-&gt;rchild;<br>        &#125;<br>        //此时s指向被删结点的直接前驱，p指向s的父母节点<br>        p-&gt;data = s-&gt;data;    //被删除结点的值替换成它的直接前驱的值<br>        if(q != *p)&#123;<br>            q-&gt;rchild = s-&gt;lchild;    //重接q的右子树<br>        &#125;else&#123;<br>            q-&gt;lchild = s-&gt;lchild;    //重接q的左子树<br>        &#125;<br>        pree(s);<br>    &#125;<br>    return TRUE;<br>&#125;<br>/*从二叉排序树中删除结点p，并重接它的左或右子树。*/<br>bool Delete(BiTree *p)&#123;<br>    BiTree q, s;<br>    if(p-&gt;rchild == NULL)&#123;<br>        //右子树为空则只需重接它的左子树<br>        q = *p;<br>        *p = (*p)-&gt;lchild;<br>        free(q);<br>    &#125;else if((*p)-&gt;lchild == NULL)&#123;<br>        //左子树为空则只需重接它的右子树<br>        q = *p;<br>        *p = (*p)-&gt;rchild;<br>        free(q);<br>    &#125;else&#123;<br>        //左右子树均不空<br>        q = *p;<br>        s = (*p)-&gt;lchild;    //先转左<br>        while(s-&gt;rchild)&#123;//然后向右到尽头，找待删结点的前驱<br>            q = s;<br>            s = s-&gt;rchild;<br>        &#125;<br>        //此时s指向被删结点的直接前驱，p指向s的父母节点<br>        p-&gt;data = s-&gt;data;    //被删除结点的值替换成它的直接前驱的值<br>        if(q != *p)&#123;<br>            q-&gt;rchild = s-&gt;lchild;    //重接q的右子树<br>        &#125;else&#123;<br>            q-&gt;lchild = s-&gt;lchild;    //重接q的左子树<br>        &#125;<br>        free(s);<br>    &#125;<br>    return TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>平衡二叉树</strong>（AVL）：</p>
<p>一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1，即它是一种高度平衡的二叉排序树；</p>
<p>它要么是一棵空树， 要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1；</p>
<p>在二叉排序树插入保持平衡：</p>
<p>1.LL平衡旋转（右单旋转）。由于在结点 A 的左孩子（ L ）的左子树（ L ）上插入了新结点， A 的平衡因子由1增至2，导致以 A 为根的子树失去平衡，需要一次向右的旋转操作。将 A 的左孩子 B 向右上旋转代替 A 成为根结点，将 A 结点向右下旋转成为 B 的右子树的根结点，而 B 的原右子树则作为 A 结点的左子树。</p>
<p>2.RR平衡旋转（左单旋转）。由于在结点 A 的右孩子的右子树上插入了新结点， A 的平衡因子由﹣1减至﹣2，导致以 A 为根的子树失去平衡，需要一次向左的旋转操作。将 A 的右孩子 B 向左上旋转代替 A 成为根结点，将 A 结点向左下旋转成为 B 的左子树的根结点，而 B 的原左子树则作为 A 结点的右子树。</p>
<p>3.LR平衡旋转（先左后右双旋转）。由于在 A 的左孩子（ L ）的右子树上插入新结点， A 的平衡因子由1增至2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将 A 结点的左孩子 B 的右子树的根结点 C 向左上旋转提升到 B 结点的位置（即进行一次 RR 平衡旋转（左单旋转）)，然后再把该 C 结点向右上旋转提升到 A 结点的位置（即进行一次 LL 平衡旋转（右单旋<br>转）)。</p>
<p>4.rl平衡旋转（先右后左双旋转）。由于在 A 的右孩子的左子树（ L ）上插入新结点， A 的平衡因子由﹣1减至﹣2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将 A 结点的右孩子 B 的左子树的根结点 C 向右上旋转提升到 B 结点的位置（即进行一次 LL 平衡旋转（右单旋转）)，然后再把该 C 结点向左上旋转提升到 A 结点的位置（即进行一次 RR 平衡旋转（左单旋<br>转）)。</p>
<h3 id="赫夫曼树-Huffman-："><a href="#赫夫曼树-Huffman-：" class="headerlink" title="赫夫曼树(Huffman)："></a>赫夫曼树(Huffman)：</h3><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目叫做<strong>路径长度</strong>，<strong>树的路径长度</strong>是从树根到每一个结点的路径长度之和；</p>
<p>树中结点常常被赋予一个表示某种意义的数值，称为该结点的<strong>权</strong>;</p>
<p>从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的<strong>带权路径长度</strong>;</p>
<p>树中所有叶结点的带权路径长度之和称为该树的<strong>带权路径长度</strong>;</p>
<p>构造树：</p>
<ul>
<li><p>根据给定的 n 个权值 {w1 , w2 , …, wn }，构造 n 棵二叉树的集合 F = {T1 , T2 , … , Tn }，其中每棵二叉树中均只含一个带权 值为 wi 的根结点，其左、右子树为空树；</p>
</li>
<li><p>在F 中选取其根结点的权值为最小和次小的两棵二叉树， 分别作为左、右子树构造一棵新的二叉树，并置这棵新的二叉树根结点的权值为其左、右子树根结点的权值之和；</p>
</li>
<li><p>从F中删去这两棵树，同时加入刚生成的新树；</p>
</li>
<li><p>重复 2 和 3 两步，直至 F 中只含一棵树为止；</p>
</li>
</ul>
<p>构造赫夫曼树编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*哈夫曼树结构*/<br>//可以用数组连续存储，不会浪费空间<br>//故用数组下标存储左右孩子、父亲结点<br>typedef struct<br>&#123;<br>    int weight;<br>    int left;<br>    int right;<br>    int parent;<br>&#125;Node, * HuffmanTree;<br>void CreateHuffmanTree(HuffmanTree* T, int w[], int n)<br>&#123;<br>    int m = 2 * n - 1;//n个叶子结点，共m个结点<br>    int m1, m2;//用于建立下一个结点的两结点，值为最小的两个<br>    *T = (HuffmanTree)malloc((m + 1) * sizeof(Node));<br>    //初始化前n个结点（叶子结点），权重赋值，暂时没有左右孩子与父亲<br>    for (int i = 1; i &lt;= n; i++)<br>    &#123;<br>        (*T)[i].weight = w[i];<br>        (*T)[i].left = 0;<br>        (*T)[i].right = 0;<br>        (*T)[i].parent = 0;<br>    &#125;<br><br>    //初始化[n+1,m]个结点(非叶子结点)<br>    for (int i = n + 1; i &lt;= m; i++)<br>    &#123;<br>        (*T)[i].weight = 0;<br>        (*T)[i].left = 0;<br>        (*T)[i].right = 0;<br>        (*T)[i].parent = 0;<br>    &#125;<br><br>    //开始建树，第i个结点的两孩子为m1,m2，权重为两孩子结点权重之和<br>    for (int i = n + 1; i &lt;= m; i++)<br>    &#123;<br>        select(T, i - 1, &amp;m1, &amp;m2);<br>        (*T)[i].left = m1;<br>        (*T)[i].right = m2;<br>        (*T)[m1].parent = i;<br>        (*T)[m2].parent = i;<br>        (*T)[i].weight = (*T)[m1].weight + (*T)[m2].weight;<br>        printf(&quot;%d (%d %d)\n&quot;, (*T)[i].weight, (*T)[m1].weight, (*T)[m2].weight);<br>    &#125;<br>    printf(&quot;\n&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*选取得到n个无父节点的两最小结点*/<br>void select(HuffmanTree* T, int n, int* m1, int* m2)<br>&#123;<br>    int m;//存储最小值的数组下标<br><br>    //给m赋初值<br>    for (int i = 1; i &lt;= n; i++)<br>    &#123;<br>        if ((*T)[i].parent == 0)<br>        &#123;<br>            m = i;<br>            break;<br>        &#125;<br>    &#125;<br>    //找到当前最小的权重（叶子结点）<br>    for (int i = 1; i &lt;= n; i++)<br>    &#123;<br>        if ((*T)[i].parent == 0 &amp;&amp; (*T)[i].weight &lt; (*T)[m].weight)<br>        &#123;<br>            m = i;<br>        &#125;<br>    &#125;<br>    //先赋给m1保存一个，再去寻找第二小的值<br>    *m1 = m;<br>    for (int i = 1; i &lt;= n; i++)<br>    &#123;<br>        if ((*T)[i].parent == 0 &amp;&amp; i != *m1)<br>        &#123;<br>            m = i;<br>            break;<br>        &#125;<br>    &#125;<br>    for (int i = 1; i &lt;= n; i++)<br>    &#123;<br>        if ((*T)[i].parent == 0 &amp;&amp; i != *m1 &amp;&amp; (*T)[i].weight &lt; (*T)[m].weight)<br>        &#123;<br>            m = i;<br>        &#125;<br>    &#125;<br>    //保存第二小的数<br>    *m2 = m;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*创建哈夫曼编码*/<br>//从n个叶子结点到根节点逆向求解<br>void CreateHuffmanCode(HuffmanTree* T, HuffmanCode* C, int n)<br>&#123;<br>    //编码长度为s-1,第s位为\0<br>    int s = n - 1;<br>    //当前结点的父节点数组下标<br>    int p = 0;<br>    //为哈夫曼编码分配空间<br>    C = (HuffmanCode*)malloc((n + 1) * sizeof(char*));<br>    //临时保存当前叶子结点的哈夫曼编码<br>    char* cd = (char*)malloc(n * sizeof(char));<br>    //最后一位为\0<br>    cd[n - 1] = &#x27;\0&#x27;;<br><br>    for (int i = 1; i &lt;= n; i++)<br>    &#123;<br>        s = n - 1;<br>        //c指向当前结点,p指向此结点的父节点,两者交替上升，直到根节点<br>        for (int c = i, p = (*T)[i].parent; p != 0; c = p, p = (*T)[p].parent)<br>        &#123;<br>            //判断此结点为父节点的左孩子还是右孩子<br>            if ((*T)[p].left == c)<br>                cd[--s] = &#x27;0&#x27;;//左孩子就是编码0<br>            else<br>                cd[--s] = &#x27;1&#x27;;//右孩子就是编码1<br>        &#125;<br>        //为第i个编码分配空间<br>        C[i] = (char*)malloc((n - s) * sizeof(char));<br>        //将此编码赋值到整体编码中<br>        strcpy(C[i], &amp;cd[s]);<br>    &#125;<br>    //释放<br>    free(cd);<br>    //打印编码序列<br>    for (int i = 1; i &lt;= n; i++)<br>    &#123;<br>        printf(&quot;%d %s&quot;, (*T)[i].weight, C[i]);<br>        printf(&quot;\n&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"></div><div id="Valine"></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/3226021048XTC">Dr.落叶潇潇</a></h1><div id="description"><p>感</p><p>染</p><p>者</p><p>应</p><p>该</p><p>为</p><p>自</p><p>己</p><p>的</p><p>身</p><p>份</p><p>而</p><p>骄</p><p>傲</p><p>，</p><p> </p><p>并</p><p>用</p><p>最</p><p>简</p><p>单</p><p>的</p><p>手</p><p>段</p><p>夺</p><p>取</p><p>大</p><p>地</p><p>的</p><p>公</p><p>正</p></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91-1"><span class="toc-number">1.0.2.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91-Huffman-%EF%BC%9A"><span class="toc-number">1.0.3.</span> <span class="toc-text">赫夫曼树(Huffman)：</span></a></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">罗德岛：R111</a></nobr><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'LSe7mf1XYliLqgIrc3jlqXfT-gzGzoHsz'
 , appKey: 'Fu9giJfnidkCamaW89FUpidw' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"left","width":300,"height":600,"hOffset":-15,"vOffset":-15},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>